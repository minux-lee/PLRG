\documentclass[10pt,conference]{IEEEtran}

\usepackage{times}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{simplebnf}
\usepackage[margin=0.75in]{geometry}
\usepackage{framed}

\setlength{\jot}{6pt}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Rust}{
  keywords={break, const, continue, crate, else, enum, extern, false, fn, for, 
if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, 
static, struct, super, trait, true, type, unsafe, use, where, while, as, async, 
await, dyn},
  keywordstyle=\color{magenta},
  ndkeywords={u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64, str,
 String, char, bool, Option, Result, Some, None, Ok, Err, Box, Vec},
  ndkeywordstyle=\color{blue},
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{codepurple}\ttfamily,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\lete}[3]{\ensuremath{\mathsf{let}\ #1\ \mathsf{=}\ #2\ \mathsf{in}\ #3}}
\newcommand{\lett}[4]{\ensuremath{\mathsf{let}\ #1\mathsf{:}\,#2\ \mathsf{=}\ #3\ \mathsf{in}\ #4}}
\newcommand{\binop}[2]{\ensuremath{#1\ \mathsf{\oplus}\ #2}}
\newcommand{\ternary}[3]{\ensuremath{\mathsf{if0}\ #1\ \mathsf{then}\ #2\ \mathsf{else}\ #3}}
\newcommand{\func}[2]{\ensuremath{\lambda #1.#2}}
\newcommand{\funct}[3]{\ensuremath{\lambda #1\mathsf{:}\,#2.#3}}
\newcommand{\apply}[2]{\ensuremath{#1\ #2}}
\newcommand{\raw}[1]{\ensuremath{#1\mathsf{.raw}}}
\newcommand{\arrowt}[2]{\ensuremath{{#1}\rightarrow{#2}}}
\newcommand{\checktype}[4]{\ensuremath{{check}(#1,\,#2)=(#3,\,#4)}}
\newcommand{\requiretype}[4]{\ensuremath{{require}(#1,\,#2,\,#3)=#4}}
\newcommand{\required}[1]{\ensuremath{#1\text{ is required}}}
\newcommand{\nrequired}[1]{\ensuremath{#1\text{ is not required}}}
\newcommand{\forcerequire}[2]{\ensuremath{#1\Rightarrow#2}}

\begin{document}

\title{Enhancing C-to-Rust Translation with Subtype Inference for Enum Types}

\author{
    \IEEEauthorblockN{Minwook Lee}
    \IEEEauthorblockA{ryan-lee@kaist.ac.kr}
}

\maketitle

\begin{abstract}
Automatic C-to-Rust translation is a promising way to improve the reliability of legacy C software. However, the existing C2Rust translator primarily performs direct syntactic conversion, which often fails to produce idiomatic Rust code and thus undermines the goal of safer, more reliable software.

For example, in C an \texttt{enum} is effectively just an integer type and does not ensure that a variable only holds one of its defined variant values. Consequently, C2Rust translates C enums as integers in Rust, using type aliases and constants for the variants. In contrast, Rust's \texttt{enum} type enforces that only valid variant values can be assigned and supports pattern matching for variant-specific behavior. Ideally, a translation tool should convert C enums into real Rust enums to take advantage of these safety features.

In this report, we introduce a subtype inference technique to enhance C2Rust's handling of enum types. This approach analyzes the usage of an enum in the C code to determine if it can safely be represented as a Rust enum. If so, the translator replaces the integer alias with a proper Rust enum definition. This enhancement leverages Rust's safety and expressiveness, yielding translated code that is more idiomatic and type-safe.
\end{abstract}

\section{Background and Motivation}

\subsection{Enumeration Types in C and Rust}
In C, an \texttt{enum} is essentially a set of named integer constants; the language does not enforce that an enum variable holds only the defined variant values. Each enumerator is assigned an integer (either explicitly or by default in sequence), and different enum types can even share the same underlying values. This means a program can assign an integer value to an enum variable even if that value doesn't correspond to any defined variant. Consider the following code example:

\begin{lstlisting}[language=C]
enum Color {
    r, // 0
    g, // 1
    b = 3
};

int main() {
    enum Color color = r;
    color = 4; // no error
    return 0;
}
\end{lstlisting}

In this C code, the \texttt{enum Color} defines three variants, where \texttt{r} and \texttt{g} are implicitly mapped to 0 and 1, and \texttt{b} is explicitly mapped to 3. In the \texttt{main} function, the variable \texttt{color} is declared as type \texttt{Color} and initialized to \texttt{r}. However, the code then assigns \texttt{color = 4}, which is not one of the defined variants, and C allows this without any error. This illustrates that C enums do not provide value safety.

In contrast, Rust's \texttt{enum} type ensures value safety and is more expressive. Each variant in a Rust enum is distinct and cannot be conflated with an unrelated integer value. Moreover, Rust allows pattern matching on enums, enabling clear and type-safe differentiation of variants in code. The following Rust example demonstrates these properties:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, // 0
    G, // 1
    B = 3,
}

fn main() {
    let mut color = Color::R;
    assert!(color as i32 == 0);
    // color = 4; // error: mismatched types
    // color = 4 as Color; // error: can't cast integer to enum
}
\end{lstlisting}

Note that Rust enums are a form of algebraic data type and can be more expressive (for example, variants can hold associated data), but here we restrict our focus to simple C-like enums with integer values. In the Rust code above, the enum \texttt{Color} has three variants (\texttt{R}, \texttt{G}, and \texttt{B}) corresponding to 0, 1, and 3 respectively. In \texttt{main}, the variable \texttt{color} is of type \texttt{Color} and is initialized to \texttt{Color::R}. Any attempt to assign an out-of-range value (such as \texttt{4}) to \texttt{color} results in a compile-time error. This demonstrates that Rust enums guarantee an enum variable cannot hold values outside its defined variants.

\subsection{C2Rust's Enum Translation}

C2Rust is a tool for translating C code to Rust. Although it can handle enums, in practice C2Rust translates each C enum into a Rust integer type alias (with constants for the variants) rather than using a proper Rust enum type. This means it fails to leverage Rust's value safety and expressiveness for enums. The limitation stems from C2Rust's reliance on straightforward syntactic transformations.

For example, consider the C enumeration below and how C2Rust translates it:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};
\end{lstlisting}

C2Rust produces the following Rust code:

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;
\end{lstlisting}

In this output, the enum is essentially lost: \texttt{Color} is defined as an alias for \texttt{libc::c\_uint}, and each variant is a constant of that type. The translated code behaves like an untyped integer, not leveraging Rust's enum features or value checking.

In C, an enum type is effectively interchangeable with an integer type (it is just a labeled alias), so C2Rust's current translation is technically faithful as a direct transformation. However, if a developer explicitly uses an enum type name in a variable or function declaration, it implies an intention that the variable should only take on values from that enum's set of variants. If we can verify from the code that this intention is respected (i.e., only valid variant values are ever assigned to that variable), then it would be more appropriate for the translated Rust code to use a real enum type instead of a plain integer.

For these reasons, we propose to augment C2Rust with a subtype inference mechanism for enums. This mechanism determines if a given C enum's usage is consistent with a Rust enum's constraints, and if so, translates it into an actual Rust enum (replacing the integer alias). The goal is to produce translated code that fully benefits from Rust's safety features and clarity.

\section{Approach}

\subsection{Na\"ive Translation}

A straightforward idea would be to always translate a C enum into a Rust enum in the output, as long as doing so does not break the code's correctness. For example, consider the following C code and how C2Rust currently translates it:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};

int ctoi(const enum Color color) {
    switch (color) {
        case r:
            return 0x0000ff;
        case g:
            return 0x00ff00;
        case b:
            return 0xff0000;
    }
    return -1;
}
\end{lstlisting}

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color as libc::c_uint {
        0 => return 0xff as libc::c_int,
        1 => return 0xff00 as libc::c_int,
        2 => return 0xff0000 as libc::c_int,
        _ => {}
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

C2Rust's translation above leaves \texttt{Color} as an alias for \texttt{c\_uint}. Suppose instead we manually alter the translation to use a Rust enum for \texttt{Color}:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, G, B
}

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color {
        Color::R => return 0xff as libc::c_int,
        Color::G => return 0xff00 as libc::c_int,
        Color::B => return 0xff0000 as libc::c_int,
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

In this instance, replacing the alias with a real Rust enum works correctly. As long as the C code never introduces invalid values for \texttt{Color}, translating it directly to a Rust enum is sound. However, now consider an additional piece of code added to this program:

\begin{lstlisting}[language=C, label=lst:example]
// ...

int foo() {
    const int green = 1;
    return ctoi(green);
}
\end{lstlisting}

In the \texttt{foo} function above, C allows an implicit conversion: the constant integer \texttt{green} (value 1) is passed to \texttt{ctoi}, which expects an enum \texttt{Color}. Rust, however, does not permit implicitly or explicitly casting an integer to an enum type. As a result, calling \texttt{ctoi(green)} would not compile in Rust (even an attempt like \texttt{ctoi(green as Color)} is disallowed). This scenario highlights why C2Rust sticks to integer types for enums; a na\"ive direct conversion would break here. We need a more nuanced approach to handle such cases. To address this, we propose a technique called \emph{subtype inference}.

\subsection{Subtype Inference}

Our approach introduces the concept of treating the C enum type as a subtype of a general integer type. In other words, we assume a C enum $\epsilon$ should allow only the values defined by its variants (making it, conceptually, a subset of $\mathbb{Z}$). Under this interpretation, we enforce that any variable declared with type $\epsilon$ can only be assigned one of the enum's variant values. In C, this property is not enforced by the compiler (any integer can be assigned), whereas in Rust the compiler does enforce it (an enum variable can only be one of its variants).

With subtype inference, we analyze the program to infer whether an enum type is consistently used in a restricted way (only holding its variant values). If so, we consider that enum to be a subtype of the integer type, meaning it effectively behaves like an integer with a limited range. We then translate it as a Rust enum. This analysis requires examining every usage of the enum in the C code and checking that any value assigned to a variable of that type is indeed one of the defined variant values.

For a concrete illustration, revisit the earlier \texttt{foo} example. We assume that whenever the code explicitly uses the enum's name in a type annotation, it is intended to truly be of that enum type. Under this assumption:
\begin{itemize}
    \item The parameter \texttt{c} of function \texttt{ctoi} is declared as type \texttt{Color}, so we treat it as genuinely meant to be a \texttt{Color}.
    \item In the body of \texttt{foo}, the variable \texttt{green} is passed to \texttt{ctoi}. This usage suggests that \texttt{green} should be considered a \texttt{Color} as well (since it is being used where a \texttt{Color} is expected).
    \item We accordingly change \texttt{green}'s declaration from \texttt{const int green = 1;} to \texttt{const Color green = 1;}.
    \item We then verify that this change does not introduce any type errors. In this case, the initializer value \texttt{1} is indeed one of the defined \texttt{Color} variants (assuming \texttt{r=0}, \texttt{g=1}, \texttt{b=3} as earlier), so the assignment is valid under the new type.
\end{itemize}

If we can apply such transformations for all instances where the enum is used (and none of them produce a type error), then the C enum in question can safely be translated into a Rust enum. In the next section, we formalize this approach with a formal grammar and inference rules.

\section{Formal Definitions and Assumptions}

\subsection{Notation}

We introduce the following notation for our formalization:
\begin{enumerate}
    \item Let $\epsilon$ denote the particular enum type under consideration for translation.
    \item Let $V_\epsilon$ be the set of all integer values corresponding to the variants of $\epsilon$ (i.e., the values that $\epsilon$ can take).
\end{enumerate}

\subsection{Assumptions}
Our approach relies on several assumptions:
\begin{enumerate}
    \item The C code is well-typed (we assume no type errors in the input program), and the type of every variable can be determined.
    \item If the enum type's name $\epsilon$ is explicitly used in a variable or parameter declaration in the C code, we assume the type of that variable is intended to be $\epsilon$.
    \item For simplicity, assume that all parameter and variable identifier names are distinct (no naming collisions).
    \item We maintain an associated type environment $\Gamma$ (with elements stored in a set $TEnv$) that records variables and their associated required types.
\end{enumerate}

\subsection{Type Checking and Requirement Functions}
We define two functions to formalize the checking of expressions and enforcement of required types:
\begin{itemize}
    \item $check(\Gamma, e)$: Performs standard type checking on expression $e$ under environment $\Gamma$. It returns the inferred type $\tau$ of $e$ and an updated associated type environment $\Gamma$. This function is used in the general case where there are no special developer requirements on types.
    \item $require(\Gamma, e, \tau)$: Checks expression $e$ under environment $\Gamma$ with the requirement that $e$'s type must be exactly $\tau$. It returns the associated type environment $\Gamma$ after enforcing this requirement. This function is used when a specific type is expected for an expression (for example, due to an explicit annotation or context).
\end{itemize}

\section{Formal Rules for Subtype Inference}

\subsection{Basic Expression Language (No Functions)}
\subsubsection{Abstract Syntax}
We first define an abstract syntax for a simple language of expressions (without functions) to model our approach:

\vspace{0.5em}
\begin{bnf}
    $\tau$ ::= $\epsilon$ | $\Z$
\end{bnf}

\begin{bnf}
    $e$ ::= \lett{x}{\tau}{e}{e} 
    | $x$ 
    | $n$ 
    | \binop{e}{e} 
    | \ternary{e}{e}{e}
\end{bnf}
\vspace{0.5em}

\subsubsection{Subtype and Required Type}
We treat the enum type $\epsilon$ as a subtype of the integer type $\Z$. We also introduce a notion of a "required" type for enforcing enum types in certain contexts. The formal rules for subtyping and required types are given in Figure~\ref{fig:subtype-required-rules}.

\begin{figure}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Sub-Epsilon:}} &\quad \epsilon <: \Z \\
\text{\textsc{Sub-Refl:}} &\quad \tau <: \tau \\
\text{\textsc{Req-Enum:}} &\quad \infer{\required{\tau}}{\tau = \epsilon} \\
\text{\textsc{Force-Req:}} &\quad \infer{\forcerequire{\tau_1}{\tau_2}}{\required{\tau_2} \quad \tau_2 <: \tau_1}
\end{align*}
\end{framed}
\caption{Subtype relation and required-type rules (for the base language). Rule \textsc{Sub-Epsilon} declares the enum type $\epsilon$ to be a subtype of the integer type $\Z$, and \textsc{Sub-Refl} allows any type to be a subtype of itself. Rule \textsc{Req-Enum} tags $\epsilon$ as a required type (indicating that contexts expecting this type must enforce it), and \textsc{Force-Req} states that if $\tau_2$ is required and $\tau_2 <: \tau_1$, then $\tau_1$ can be forced to a required subtype $\tau_2$.}
\label{fig:subtype-required-rules}
\end{figure}

\subsubsection{Type Checking}
The type checking rules for expressions (without functions) are given in Figure~\ref{fig:type-checking-rules}.

\begin{figure*}[ht]
\normalsize
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Check-Var:}} &\quad \checktype{\Gamma}{x}{\Gamma(x)}{\emptyset} \\
\text{\textsc{Check-ConstNonEnum:}} &\quad \infer{\checktype{\Gamma}{n}{\Z}{\emptyset}}{n \notin V_\epsilon} \\
\text{\textsc{Check-ConstEnum:}} &\quad \infer{\checktype{\Gamma}{n}{\epsilon}{\emptyset}}{n \in V_\epsilon} \\
\text{\textsc{Check-Subsumption:}} &\quad \infer{\checktype{\Gamma}{e}{\tau}{\Gamma_1}}{\checktype{\Gamma}{e}{\tau'}{\Gamma_1} \quad \tau' <: \tau} \\
\text{\textsc{Check-BinOp:}} &\quad \infer{\checktype{\Gamma}{\binop{e_1}{e_2}}{\Z}{\Gamma_1 \cup \Gamma_2}}{\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \quad \checktype{\Gamma}{e_2}{\Z}{\Gamma_2}} \\
\text{\textsc{Check-Ternary:}} &\quad \infer{\checktype{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1 \cup \Gamma_2 \cup \Gamma 3}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \\
\checktype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad \checktype{\Gamma}{e_3}{\tau}{\Gamma_3}
\end{array}
} \\
\text{\textsc{Check-Let-Req:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}
\end{array}
} \\
\text{\textsc{Check-Let-NoReq:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x \notin \text{Domain}(\Gamma_2)
\end{array}
} \\
\text{\textsc{Check-Let-Force:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \\
\checktype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x) = \tau
\end{array}
}
\end{align*}
\end{framed}
\caption{Type checking rules for the base language (no functions). \textsc{Check-Var} retrieves a variable's type from the environment. \textsc{Check-ConstNonEnum} and \textsc{Check-ConstEnum} classify a numeric literal as type $\Z$ or $\epsilon$ depending on whether its value belongs to $V_\epsilon$. \textsc{Check-Subsumption} allows an expression of a subtype to be used as a supertype. \textsc{Check-BinOp} and \textsc{Check-Ternary} ensure that binary operations use integer operands and that a ternary conditional has an integer condition and consistent branch result types. Finally, \textsc{Check-Let-Req}, \textsc{Check-Let-NoReq}, and \textsc{Check-Let-Force} handle let-bindings: enforcing required types, handling the absence of a requirement, and forcing a required subtype, respectively.}
\label{fig:type-checking-rules}
\end{figure*}

\subsubsection{Type Requiring}
The rules for requiring (asserting) specific types are given in Figure~\ref{fig:type-requiring-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Require-Var-Env:}} &\quad \infer{\requiretype{\Gamma}{x}{\tau}{[x:\tau]}}{\Gamma(x) = \tau' \quad \tau <: \tau'} \\
\text{\textsc{Require-ConstEnum:}} &\quad \infer{\requiretype{\Gamma}{n}{\epsilon}{\emptyset}}{n \in V_\epsilon} \\
\text{\textsc{Require-Expr-NoReq:}} &\quad \infer{\requiretype{\Gamma}{e}{\tau}{\Gamma_1}}{\nrequired{\tau} \quad \checktype{\Gamma}{e}{\tau}{\Gamma_1}} \\
\text{\textsc{Require-Var-Expr:}} &\quad \infer{\requiretype{\Gamma}{x}{\tau}{\Gamma_1}}{\checktype{\Gamma}{x}{\tau'}{\Gamma_1} \quad \tau' <: \tau} \\
\text{\textsc{Require-Ternary:}} &\quad \infer{\requiretype{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \\
\requiretype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad \requiretype{\Gamma}{e_3}{\tau}{\Gamma_3}
\end{array}
} \\
\text{\textsc{Require-Let-Req:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}
\end{array}
} \\
\text{\textsc{Require-Let-NoReq:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x \notin \text{Domain}(\Gamma_2)
\end{array}
} \\
\text{\textsc{Require-Let-Force:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \\
\requiretype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x) = \tau
\end{array}
}
\end{align*}
\end{framed}
\caption{Type requirement (``require'') rules for the base language. \textsc{Require-Var-Env} adds a variable to the environment with a required type (if that required type $\tau$ is a subtype of the variable's original type $\tau'$). \textsc{Require-ConstEnum} asserts that a numeric literal has type $\epsilon$ if its value is in $V_\epsilon$. \textsc{Require-Expr-NoReq} processes an expression normally when no special requirement applies. \textsc{Require-Var-Expr} handles requiring a variable expression to have a certain type by checking it and ensuring the actual type is a subtype of the required type. \textsc{Require-Ternary} enforces that both branches of a conditional expression meet the required type. Finally, \textsc{Require-Let-Req}, \textsc{Require-Let-NoReq}, and \textsc{Require-Let-Force} impose type requirements in let-binding contexts analogously to the type checking rules.}
\label{fig:type-requiring-rules}
\end{figure*}

\subsection{Extension: First-Class Functions}
\subsubsection{Abstract Syntax}
We now extend the language syntax to include first-class functions:

\vspace{0.5em}
\begin{bnf}
    $\tau$ ::= $\cdots$ | \arrowt{\tau}{\tau}
\end{bnf}

\begin{bnf}
    $e$ ::= $\cdots$ 
    | \funct{x}{\tau}{e} 
    | \apply{e}{e}
\end{bnf}
\vspace{0.5em}

This extension adds function types ($\tau_1 \to \tau_2$), lambda abstractions (anonymous functions), and function application to our language.

\subsubsection{Subtype and Required Type}
The additional rules for subtyping and required types with function types are shown in Figure~\ref{fig:function-subtype-rules}.

\begin{figure}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Req-Arrow:}} &\quad \infer{\required{\arrowt{\tau_1}{\tau_2}}}{\required{\tau_2}} \\
\text{\textsc{Sub-Arrow:}} &\quad \infer{\arrowt{\tau_1}{\tau_2} <: \arrowt{\tau_3}{\tau_4}}{\tau_3 <: \tau_1 \quad \tau_2 <: \tau_4}
\end{align*}
\end{framed}
\caption{Additional subtyping and requirement rules for function types. \textsc{Req-Arrow} marks a function type as required if its return type is required (i.e., if $\tau_2$ must be $\epsilon$, then the function type $\tau_1 \to \tau_2$ is considered required). \textsc{Sub-Arrow} is the subtyping rule for function types: $\tau_1 \to \tau_2$ is a subtype of $\tau_3 \to \tau_4$ if $\tau_3$ is a subtype of $\tau_1$ (parameter types are contravariant) and $\tau_2$ is a subtype of $\tau_4$ (return types are covariant).}
\label{fig:function-subtype-rules}
\end{figure}

\subsubsection{Type Checking}
The type checking rules for function abstractions and application are shown in Figure~\ref{fig:function-check-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Check-Lambda-Req:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{\required{\tau_1} \quad \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}} \\
\text{\textsc{Check-Lambda-NoReq:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\nrequired{\tau_1} \\
\checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x \notin \text{Domain}(\Gamma_1)
\end{array}
} \\
\text{\textsc{Check-Lambda-Force:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\forcerequire{\tau}{\tau_1} \quad \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \\
\Gamma_1(x) = \tau_1
\end{array}
} \\
\text{\textsc{Check-Apply:}} &\quad \infer{\checktype{\Gamma}{\apply{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{\requiretype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1} \quad \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_2}}
\end{align*}
\end{framed}
\caption{Extended type checking rules to support first-class functions. The \textsc{Check-Lambda-*} rules handle type checking of lambda (anonymous function) expressions under three scenarios: when the parameter's type is required (\textsc{Check-Lambda-Req}), when the parameter has no special requirement (\textsc{Check-Lambda-NoReq}), and when a required subtype must be enforced for the parameter (\textsc{Check-Lambda-Force}). \textsc{Check-Apply} checks a function application by first ensuring the function expression has an arrow type and then requiring the argument expression to have the function's parameter type.}
\label{fig:function-check-rules}
\end{figure*}

\subsubsection{Type Requiring}
Finally, the requirement rules for function-related expressions are given in Figure~\ref{fig:function-require-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Require-Lambda-Req:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{\required{\tau_1} \quad \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}} \\
\text{\textsc{Require-Lambda-NoReq:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\nrequired{\tau_1} \\
\requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x \notin \text{Domain}(\Gamma_1)
\end{array}
} \\
\text{\textsc{Require-Lambda-Force:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\forcerequire{\tau}{\tau_1} \quad \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \\
\Gamma_1(x) = \tau_1
\end{array}
} \\
\text{\textsc{Require-Apply:}} &\quad \infer{\requiretype{\Gamma}{\apply{e_1}{e_2}}{\tau_2}{\Gamma_2 \cup \Gamma_3}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\arrowt{\tau_3}{\tau_4}}{\Gamma_1} \quad \tau_1 <: \tau_3 \\
\requiretype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_2} \quad \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_3}
\end{array}
}
\end{align*}
\end{framed}
\caption{Extended requirement rules for first-class functions. \textsc{Require-Lambda-Req} enforces an expected parameter type on a lambda expression (if the parameter's type is required to be $\epsilon$). \textsc{Require-Lambda-NoReq} handles a lambda with no special parameter requirement (ensuring the parameter is not inadvertently inferred to a required type elsewhere). \textsc{Require-Lambda-Force} forces a lambda's parameter to have a specific subtype if needed. \textsc{Require-Apply} imposes requirements when a function is applied: it first checks that the function has a suitable arrow type (and may refine the expected parameter type $\tau_1$ if it was too general), and then requires the argument to have that parameter type $\tau_1$.}
\label{fig:function-require-rules}
\end{figure*}

\section{Applying to Translation}

\subsection{Propositions}

Based on the above rules, we formulate two propositions about translating an enum type using this approach:

Let $e$ be a well-typed C program, and let $e'$ be the program obtained by changing the declared type of every variable (and parameter) in $e$ that explicitly uses the enum type $\epsilon$ to $\epsilon$ (if it isn't already). Then:
\begin{enumerate}
    \item If $check(\emptyset,\, e')$ succeeds (i.e., all the type-checking rules can be applied without failure on $e'$), it verifies that the enum type $\epsilon$ can be treated as a subtype of the integer type (meaning that $\epsilon$ can be safely translated as a Rust enum type).
    \item Suppose $\checktype{\emptyset}{e'}{\tau}{\Gamma_1}$ (the type checker infers type $\tau$ for $e'$ and produces environment $\Gamma_1$). If we then modify the declared type of every variable $x$ found in $\Gamma_1$ to $\Gamma_1(x)$ in the original program (producing a new program $e''$), then $e''$ is well-typed. In other words, after inferring the appropriate enum types via $\Gamma_1$, applying those types back to the program yields a consistent, type-correct program.
\end{enumerate}

We do not present a formal proof of these propositions here. Instead, we illustrate them with examples to show that the formal rules behave as intended.

\subsection{Examples}
We first consider a simple code fragment (assuming that $0 \in V_\epsilon$):
\[
\lett{x}{\Z}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

In this code, $y$ is explicitly declared with type $\epsilon$, so we interpret that as the developer intending $y$ to be of the enum type. To avoid any type errors, our system should infer that $x$ also has type $\epsilon$ because $x$ is initialized to $0$ (and we assumed $0 \in V_\epsilon$). Inferring $x:\epsilon$ is valid here since $0$ is one of $\epsilon$'s variant values. In contrast, $z$ is declared as an $\mathbb{Z}$ (integer) and has no connection to $\epsilon$ apart from coincidentally being assigned $0$. Therefore, $z$ should \emph{not} be inferred as type $\epsilon$.

By applying the subtype inference rules, we find that only $x$ gets associated with the enum type $\epsilon$ (while $z$ remains an integer).

If we then change the declaration of the associated variable $x$ to use type $\epsilon$ (as inferred), the resulting code becomes well-typed with the enum type correctly applied:
\[
\lett{x}{\epsilon}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

We can also confirm that this approach works when functions are involved. Consider the following example:
\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\Z}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

In this code, the function \texttt{ctoi} expects a parameter of type $\epsilon$ and returns an integer (the value multiplied by 3). The variable \texttt{green} is declared with type $\Z$ and assigned 1, but when we pass \texttt{green} to \texttt{ctoi}, that usage effectively associates \texttt{green} with the enum type $\epsilon$ (since \texttt{ctoi} requires an $\epsilon$ argument). Therefore, \texttt{green} should be inferred to have type $\epsilon$. Applying the formal rules confirms this inference, resulting in the following well-typed code (with \texttt{green} now declared as type $\epsilon$):
\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\epsilon}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

These examples illustrate that the formal rules correctly identify when a C enum type can be translated to a Rust enum type and guide the necessary transformations. The subtype inference approach helps determine when a C enum can be upgraded to a Rust enum in translation, and it carries out the replacement of the integer alias with a Rust enum where it is valid to do so.

\section{Conclusion}
In this report, we presented an approach to enhance C2Rust's enum translation by introducing subtype inference. Our approach determines when a given C enum can be safely translated into a Rust enum and, if feasible, replaces the integer type alias with a proper Rust enum. By leveraging Rust's value safety and expressiveness for enums, the translation process produces output code that is more idiomatic and maintains type correctness.

This approach offers several benefits. First, it improves the accuracy of the translation by inferring and enforcing the intended enum types, which leads to fewer type errors and a smoother migration from C to Rust. Second, by replacing opaque integer aliases with meaningful Rust enums, it enhances the readability and maintainability of the code. Developers can more easily understand the intent of the code when enums are used instead of generic integers.

However, our approach in its current form relies on a strict static type analysis and may fail in certain cases that a human might still consider valid enum usage. For example, consider a common C idiom:

\begin{lstlisting}[language=C]
enum Day {
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
};

enum Day next_day(enum Day day) {
    return (day + 1) % 7;
}
\end{lstlisting}

This code uses an enum to represent days of the week and calculates the next day. For a successful translation to a Rust enum, we would need to deduce that the return value of \texttt{next\_day} is always between 0 and 6 (i.e., a valid \texttt{Day}). However, the type system alone cannot guarantee this property, so our formal rules would not allow translating the return type of \texttt{next\_day} as an enum. Handling such cases would require additional analysis, such as range analysis or value constraint inference. Instead of automatically concluding that an expression involving arithmetic cannot correspond to an enum, the translator could attempt to deduce constraints on the expression's possible values and determine whether it stays within the valid range of an enum's variants. Incorporating such analysis could enable us to capture more cases where a C enum type can be translated to a Rust enum type.
\end{document}
