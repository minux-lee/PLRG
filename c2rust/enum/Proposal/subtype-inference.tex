\documentclass[10pt,conference]{IEEEtran}

\usepackage{times}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{simplebnf}

% Define Rust language for listings
\lstdefinelanguage{Rust}{
  keywords={break, const, continue, crate, else, enum, extern, false, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, true, type, unsafe, use, where, while, as, async, await, dyn},
  keywordstyle=\color{magenta},
  ndkeywords={u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64, str, String, char, bool, Option, Result, Some, None, Ok, Err, Box, Vec},
  ndkeywordstyle=\color{blue},
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{codepurple}\ttfamily,
  morestring=[b]",
  morestring=[b]'
}

% Define custom colors for listings
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage[margin=0.75in]{geometry}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\Z}{\ensuremath{\mathbb{Z}}}

% template
% expression
\newcommand{\lete}[3]{\ensuremath{\mathsf{let}\ #1\ \mathsf{=}\ #2\ \mathsf{in}\ #3}}
\newcommand{\lett}[4]{\ensuremath{\mathsf{let}\ #1\mathsf{:}\,#2\ \mathsf{=}\ #3\ \mathsf{in}\ #4}}
\newcommand{\binop}[2]{\ensuremath{#1\ \mathsf{\oplus}\ #2}}
\newcommand{\ternary}[3]{\ensuremath{\mathsf{if0}\ #1\ \mathsf{then}\ #2\ \mathsf{else}\ #3}}
\newcommand{\func}[2]{\ensuremath{\lambda #1.#2}}
\newcommand{\funct}[3]{\ensuremath{\lambda #1\mathsf{:}\,#2.#3}}
\newcommand{\apply}[2]{\ensuremath{#1\ #2}}
\newcommand{\raw}[1]{\ensuremath{#1\mathsf{.raw}}}

\begin{document}

\title{Enhancing C-to-Rust Translation with Subtype Inference for Enum Types}

\author{
    \IEEEauthorblockN{Minwook Lee}
    \IEEEauthorblockA{ryan-lee@kaist.ac.kr}
}

\maketitle

\begin{abstract}
% copilot instruction: Do not directly translate the text, but rather refine it to make it more suitable for a research report abstract.

% translate: 자동 C-to-Rust 변환은 레거시 시스템 소프트웨어의 신뢰성을 향상시키는 유망한 방법입니다. 그러나 산업적으로 개발된 변환기인 C2Rust는 단순한 syntactic 변환으로 Rust 코드를 생성하기에 idiomatic한 Rust 코드를 작성하지 않으며, 변환의 목적을 저해합니다. (표절 수정이 필요한 부분만 textit로 표시)

Automatic C-to-Rust translation is a promising way to enhance the reliability of legacy system software. However, C2Rust, an industrially developed translator, generates Rust code with
syntactic transformations, failing to produce idiomatic Rust code and undermining the translation's objectives.

% translate: 대표적인 예시로, C에서 enum은 integer type의 alias로, 지정된 variant의 값을 enforce하지 않습니다. 따라서 C2Rust 또한 integer type의 alias로 Rust 코드를 생성합니다. 그러나 Rust의 enum은 값의 안전성과 표현력을 제공하며, C의 enum을 Rust의 enum으로 변환하는 과정에서 이러한 특성을 최대한 활용할 수 있습니다.
A representative example is that in C, enums are treated as aliases for integer types, which do not enforce the values of specified variants. Consequently, C2Rust generates Rust code with integer type aliases. However, Rust's enums provide value safety and expressiveness, and the translation process can leverage these features by converting C enums to Rust enums.

% translate: 본 논문에서는 C2Rust의 enum 변환을 개선하기 위한 새로운 접근법을 제안합니다. 이 접근법은 C 코드에서 enum을 Rust의 enum으로 변환할 수 있는지 여부를 판단하고, 변환이 가능할 경우 integer type의 alias 대신에 Rust의 enum으로 대신 변환합니다. 이 접근법은 C2Rust의 enum 변환을 개선하여 Rust의 안전성과 표현력을 최대한 활용할 수 있도록 합니다.
This report proposes a novel approach to improve C2Rust's enum translation. The approach determines whether a C enum can be translated to a Rust enum and, if feasible, replaces the integer type alias with a Rust enum. This enhancement aims to maximize Rust's safety and expressiveness in the translation process.


\end{abstract}

% copilot instruction: Do not directly translate the text in the comment, but rather refine it to make it more suitable for a research report abstract, and make the latex template for the code or a grammer rule. If `code` is used, it should be in monospace font.

\section{Background}

\subsection{Enumeration Types in C and Rust}

% translate: C에서 enum은 정수형 타입의 별칭으로, 지정된 variant의 값을 enforce하지 않습니다. 예를 들어, C에서 enum을 정의할 때, 각 variant는 정수 값으로 매핑되며, 이 값들은 서로 다른 variant 간에 충돌할 수 있습니다. 이는 C 코드에서 enum을 사용할 때, 특정 variant가 아닌 다른 값을 할당하는 것이 가능합니다. 아래와 같은 코드 예시를 생각해볼 수 있습니다:
In C, enums are used for storing constant integer values, but do not enforce the values of specified variants. For example, when defining an enum in C, each variant is mapped to an integer value, which can lead to collisions between different variants. This allows for the assignment of values that are not specific to any variant in C code. Consider the following code example:

\begin{lstlisting}[language=C]
enum Color {
    r, // 0
    g, // 1
    b = 3
};

int main() {
    enum Color color = r;
    color = 4; // no error
    return 0;
}
\end{lstlisting}

% translate: 위의 C 코드에서, enum Color는 세 가지 variant를 정의합니다. 그러나, r과 g는 각각 0과 1로 매핑되며, b는 3으로 매핑됩니다. main 함수에서 color 변수는 r로 초기화되지만, 이후에 4라는 값을 할당할 수 있습니다. 이는 C의 enum이 값의 안전성을 제공하지 않음을 보여줍니다.
In the above C code, the enum Color defines three variants. However, \texttt{r} and \texttt{g} are mapped to 0 and 1, respectively, while \texttt{b} is mapped to 3. In the main function, the color variable is initialized to \texttt{r}, but can later be assigned the value 4. This demonstrates that C enums do not provide value safety.

% translate: 반면에, Rust의 enum은 값의 안전성과 표현력을 제공합니다. Rust에서 enum을 정의할 때, 각 variant는 고유한 값을 가지며, 이 값들은 서로 다른 variant 간에 충돌하지 않습니다. 또한, Rust의 enum은 패턴 매칭을 통해 각 variant를 쉽게 구분할 수 있습니다. 아래와 같은 코드 예시를 생각해볼 수 있습니다:
In contrast, Rust's enums provide value safety and expressiveness. When defining an enum in Rust, each variant has a unique value that does not collide with other variants. Additionally, Rust's enums allow for easy differentiation of variants through pattern matching. Consider the following code example:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, // 0
    G, // 1
    B = 3,
}

fn main() {
    let mut color = Color::R;
    assert!(color as i32 == 0);
    // color = 4; // error: mismatched types
    // color = 4 as Color; // error: can't cast integer to enum
}
\end{lstlisting}
% copilot instruction: Do not directly translate the text in the comment, but rather refine it to make it more suitable for a research report abstract, and make the latex template for the code or a grammer rule. If `code` is used, it should be in monospace font.

% translate and refine: Rust의 enum 타입은 Abstract Data Type으로 더 넓은 의미를 가지지만, 본 연구는 C의 enum 타입을 변환하기 위한 것이므로 C와 같은 형태의 enum만을 다룹니다. 위의 Rust 코드에서, enum 타입인 `Color`는 세 가지 variant를 정의합니다. 각 variant는 고유한 값을 가지며, R은 0으로 매핑되고, G는 1로 매핑되며, B는 3으로 매핑됩니다. `main` 함수에서 `color` 변수는 `Color::R`로 초기화되며, 이후에 4라는 값을 할당하려고 하면 컴파일 오류가 발생합니다. 이는 Rust의 enum이 값의 안전성을 제공함을 보여줍니다.

In Rust, the enum type is an Abstract Data Type with a broader meaning, but this study focuses on translating C enums, so we only address enums in the form similar to C. In the above Rust code, the enum type \texttt{Color} defines three variants. Each variant has a unique value: R is mapped to 0, G to 1, and B to 3. In the \texttt{main} function, the variable \texttt{color} is initialized to \texttt{Color::R}, and attempting to assign the value 4 later results in a compile-time error. This demonstrates that Rust's enums provide value safety.

\subsection{C2Rust's Enum Translation}

% translate: C2Rust는 C 코드를 Rust로 변환하는 도구로, C의 enum을 Rust의 enum으로 변환하는 기능을 제공합니다. 그러나, C2Rust는 enum을 integer type의 alias로 변환하며, Rust의 enum이 제공하는 값의 안전성과 표현력을 활용하지 않습니다. 이는 C2Rust가 단순한 syntactic 변환에 그치기 때문입니다.
C2Rust is a tool that translates C code to Rust, providing functionality to convert C enums to Rust enums. However, C2Rust translates enums as integer type aliases, failing to leverage the value safety and expressiveness offered by Rust's enums. This limitation arises because C2Rust primarily performs syntactic transformations.

% translate: 예를 들어, 아래와 같은 C 코드를 C2Rust로 변환한다고 생각해봅니다:
For example, consider the following C code that we would like to translate using C2Rust:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};
\end{lstlisting}

% translate: C2Rust는 위의 C 코드를 아래와 같이 변환합니다:
C2Rust translates the above C code as follows:

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;
\end{lstlisting}

% translate: 위의 Rust 코드에서, C2Rust는 enum을 integer type의 alias로 변환하고, 각 variant를 상수로 정의합니다. 그러나, 이는 Rust의 enum이 제공하는 값의 안전성과 표현력을 활용하지 못합니다.

In the above Rust code, C2Rust translates the enum as an integer type alias and defines each variant as a constant. However, this does not utilize the value safety and expressiveness provided by Rust's enums.

% translate: C에서 enumeration type과 int 타입 간의 관계는 단순히 type aliasing에 불과합니다. 그러므로 C2Rust에서 C의 enumeration type을 Rust의 constant integer value로 옮기는 방식은 syntactic한 변환을 수행한다는 관점에서 적절합니다. 다만, enumeration type의 이름으로 변수나 함수의 타입을 지정할 수 있기에, 개발자가 다른 변수의 선언부에서 해당 이름을 사용하여 타입을 지정했다면 enum variants 중에 값이 존재함을 의도했다고 추정할 수 있습니다. 만약 코드에서 이 사실을 증명할 수 있다면, 변환된 idiomatic한 Rust코드에서는 enum 타입을 사용해야 적절합니다. 

In C, the relationship between enumeration types and integer types is merely type aliasing. Therefore, C2Rust's approach of translating C's enumeration types to Rust's constant integer values is appropriate from the perspective of performing syntactic transformations. However, since enumeration types can be used to specify variable or function types, if a developer has used the enumeration name in another variable declaration, it can be inferred that they intended for the value to exist among the enum variants. If this fact can be proven in the code, then using an enum type in the translated idiomatic Rust code would be appropriate.

% translate: 본 논문에서는 C2Rust의 enum 변환을 개선하기 위한 새로운 접근법을 제안합니다. 이 접근법은 C 코드에서 enum을 Rust의 enum으로 변환할 수 있는지 여부를 판단하고, 변환이 가능할 경우 integer type의 alias 대신에 Rust의 enum으로 대신 변환합니다. 이 접근법은 C2Rust의 enum 변환을 개선하여 Rust의 안전성과 표현력을 최대한 활용할 수 있도록 합니다.

This report proposes a novel approach to improve C2Rust's enum translation. The approach determines whether a C enum can be translated to a Rust enum and, if feasible, replaces the integer type alias with a Rust enum. This enhancement aims to maximize Rust's safety and expressiveness in the translation process.

\section{Approach}
\subsection{Na\"ive Translation}

% 가장 쉬운 방법은 C에서 정의된 어떤 enumeration type에 대해 Rust의 enum 타입으로 변환한 후 safe and well-typed expression일 때만 채택하는 것입니다. 예를 들어, 아래와 같이 C 코드와 C2Rust를 통해 변환된 Rust 코드가 있다고 가정합니다: 

The simplest approach is to translate any enumeration type defined in C to a Rust enum type, but only adopt it when the expression is safe and well-typed. For example, consider the following C code and its translation via C2Rust:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};

int ctoi(const enum Color color) {
    switch (color) {
        case r:
            return 0x0000ff;
        case g:
            return 0x00ff00;
        case b:
            return 0xff0000;
    }
    return -1;
}
\end{lstlisting}

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color as libc::c_uint {
        0 => return 0xff as libc::c_int,
        1 => return 0xff00 as libc::c_int,
        2 => return 0xff0000 as libc::c_int,
        _ => {}
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

% C2Rust에서는 enum 타입을 integer type의 alias로 변환하는데, 이를 강제로 enum type으로 변환해본다고 해봅시다:

C2Rust translates the enum type as an integer type alias, but let's assume we force it to be an enum type:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, G, B
}

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color {
        Color::R => return 0xff as libc::c_int,
        Color::G => return 0xff00 as libc::c_int,
        Color::B => return 0xff00000 as libc::c_int
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

% 이 특정한 케이스에서는 C2Rust가 enum을 Rust의 enum으로 변환하는 것이 잘 작동합니다. C 개발자가 enumeration type에 잘못된 값이 들어가지 않도록 이상적으로 코드를 작성했다면 이 방식이 항상 작동할 것입니다. 하지만 아래와 같은 코드가 추가되었다고 생각해볼 수 있습니다.

In this specific case, C2Rust's translation of the enum to a Rust enum works well. If the C developer has ideally written the code to prevent incorrect values from entering the enumeration type, this approach will work consistently. However, consider the following additional code:

\begin{lstlisting}[language=C, label=lst:example]
// ...

int foo() {
    const int green = 1;
    return ctoi(green);
}
\end{lstlisting}

% 이 경우 C에서는 green을 Color 타입으로 변환하는 implicit conversion이 발생합니다. Rust의 enum은 이와 같은 변환을 허용하지 않기 때문에, Rust 코드에서 ctoi(green) 호출은(심지어 ctoi(green as Color) 와 같은 casting 구문을 넣더라도) 컴파일 오류를 발생시킵니다. 이는 C2Rust가 enum을 integer type의 alias로 변환하는 이유 중 하나입니다. 이러한 경우도 포함하여 올바르게 변환하기 위해서 새로운 접근법이 필요합니다. 다음 section에서는 이러한 문제를 해결하기 위한 subtype 추정이라는 새로운 접근법을 제안합니다.

In this case, an implicit conversion occurs in C, converting \texttt{green} to the \texttt{Color} type. Rust's enums do not allow such conversions, so calling \texttt{ctoi(green)} (even with a casting syntax like \texttt{ctoi(green as Color)}) results in a compile-time error. This is one of the reasons why C2Rust translates enums as integer type aliases. To correctly translate such cases, a new approach is needed. The next section proposes a novel approach called subtype inference to address these issues.

\subsection{Subtype Inference}

% 해당 접근법의 핵심 아이디어는, enum 타입을 정수 타입의 subtype으로 보는 것입니다. 이는 enum 타입으로 선언된 변수에 대해, 해당 enum 타입의 variant 중 하나로만 값을 할당할 수 있도록 보장합니다. 이 관점에서, C는 enum 타입의 변수에 아무 정수 값이나 할당할 수 있으므로 안전성을 보장하지 않고, Rust는 enum 타입의 변수에 해당 enum 타입의 variant 중 하나로만 값을 할당할 수 있도록 보장하므로 안전하다고 볼 수 있습니다.

The core idea of this approach is to view enum types as subtypes of integer types. This ensures that variables declared with an enum type can only be assigned values that are one of the variants of that enum type. From this perspective, C does not guarantee safety because it allows any integer value to be assigned to a variable of an enum type, while Rust guarantees safety by allowing only values that are one of the variants of the enum type.

% subtype 추정은 C 코드를 작성한 개발자가 enum 타입을 선언할 때, 이를 정말 정수 타입의 subtype으로 의도했는지 여부를 추정하는 것입니다. 만약 개발자가 enum 타입을 정수 타입의 subtype으로 의도했다면, Rust의 enum 타입으로 변환할 수 있습니다. 이를 위해서는 C 코드에서 enum 타입이 사용되는 모든 위치를 분석해야 합니다. 이 분석을 통해 enum 타입이 사용되는 위치에서 해당 enum 타입의 variant 중 하나로만 값을 할당하는지 확인할 수 있습니다.

Subtype inference involves deducing whether the developer intended to declare an enum type as a subtype of an integer type. If the developer did intend for the enum type to be a subtype of an integer type, it can be translated to a Rust enum type. To achieve this, all occurrences of the enum type in the C code must be analyzed. This analysis checks whether values assigned at these occurrences are one of the variants of the enum type.

% 아래와 같은 생각 정리를 논문에 잘 녹여내도록 적어야 함:
% - 예를 들어, 위에서 언급한 `foo` 함수를 다시 생각해보자. 개발자가 변수/파라미터 선언부의 타입에 “Color”라고 명시했을 때만 `Color` 타입임을 의도했다고 간주합니다. 그와 **연관된 변수**들만 검사하여 enum type으로 바꿀 수 있는지 검사합니다. 예시 코드의 경우,
    % - `ctoi`의 파라미터 타입이 “Color”로 명시되어 있습니다. 따라서 파라미터는 `Color` 타입임을 의도했다고 간주합니다.
    % - `foo` 함수의 body에서 `green`이 `ctoi`의 파라미터로 적용되었으므로 `green`의 타입은 `Color`와 연관됩니다.
    % - 연관된 변수의 선언부 `int`에서 `Color`로 수정합니다. `const Color green = 1;`로 수정됩니다.
    % - 변경된 타입이 타입 에러를 일으키지 않는지 확인합니다. 정의 구문에서 대입 연산자 오른쪽의 expression은 오로지 1이므로 바로 검증할 수 있습니다. 1은 `Color`의 variant 중 하나이므로 OK입니다.

For example, let's reconsider the \texttt{foo} function mentioned earlier. We assume that the developer intended to declare the type as ``Color" only when explicitly specified in the variable or parameter declaration. We then check only the variables associated with that declaration to see if they can be translated to an enum type. In the example code:
\begin{itemize}
    \item The parameter type of \texttt{ctoi} is explicitly declared as ``Color". Therefore, we assume that the parameter is intended to be of type \texttt{Color}.
    \item In the body of the \texttt{foo} function, \texttt{green} is applied as a parameter to \texttt{ctoi}, so we associate the type of \texttt{green} with \texttt{Color}.
    \item We modify the declaration of the associated variable from \texttt{int} to \texttt{Color}. It becomes \texttt{const Color green = 1;}.
    \item We check if the modified type does not cause a type error. In the definition statement, the right-hand side of the assignment operator is an expression that evaluates to 1, which can be immediately verified. Since 1 is one of the variants of \texttt{Color}, this is valid.
\end{itemize}

% 이와 같은 변환 방식을 연관된 모든 변수에 적용하여도 문제없음이 검증되었을 때만 해당 enumeration type을 Rust의 enum type으로 변환합니다.

If this transformation can be applied to all associated variables without issues, we can safely translate the enumeration type to a Rust enum type.

% 다음 section에서는 이 접근법을 정의하기 위한 formal한 문법을 제시합니다.
The next section presents a formal grammar to define this approach.

% 아래 섹션에 가장 어울리는 제목으로 제시
\section{Definitions}

\subsection{Notation}
% notation 들을 정의하는 섹션입니다.
We define the following notations to formalize our approach:

\begin{enumerate}
    % 변환이 가능한지 검증하고자 하는 목표 enum type을 $\epsilon$으로 정의합니다.
    \item We define the target enum type that we want to verify for translation as $\epsilon$.
    \item We denote the set of all values associated with the target enum type $\epsilon$ as $V_\epsilon$.
\end{enumerate}

\subsection{Assumptions}
% 이 접근법을 적용하기 위한 가정들을 정의합니다.
We make the following assumptions for applying this approach:

\begin{enumerate}
    % C 코드는 항상 well-typed이며, 모든 변수 선언부의 type은 inference되었다.
    \item The C code is always well-typed, and the type of every variable declaration has been inferred.
    % C 코드에서 변수의 선언부의 타입 지정에 명시적으로 enum 타입의 이름이 사용되었다면, 해당 변수의 타입은 epsilon으로 의도했다고 간주한다.
    \item If the name of the enum type is explicitly used in the variable declaration in the C code, we assume that the type of that variable is intended to be $\epsilon$.
    % 편의 상 파라미터 지정 혹은 변수 선언 시 사용된 identifier name은 모두 다르다고 가정합니다.
    \item For convenience, we assume that all identifier names used in parameter specifications or variable declarations are distinct.
    % "연관 타입 환경변수"는 TEnv의 원소로 연관된 변수와 요구하는 타입의 쌍을 모두 저장합니다.
    \item The "associated type environment variable" stores all pairs of associated variables and their required types as elements of $TEnv$.
\end{enumerate}

\subsection{Define Functions}
% 이 접근법을 정의하기 위한 함수들을 정의합니다.
We define the following functions to formalize our approach:

\newcommand{\checktype}[4]{\ensuremath{{check}(#1,\,#2)=(#3,\,#4)}}
\newcommand{\requiretype}[4]{\ensuremath{{require}(#1,\,#2,\,#3)=#4}}

\begin{itemize}
    % $check(\Gamma,e)$: 타입 체크를 통해 얻은 타입 $\tau$와 연관 타입 환경변수 $\Gamma$를 반환합니다. 개발자의 요구가 없는 일반적인 경우에 실행됩니다.
    \item $check(\Gamma,e)$: Returns the type $\tau$ obtained through type checking and the associated type environment variable $\Gamma$. This is executed in the general case where there are no specific developer requirements.
    % $require(\Gamma,e,\tau)$: 현재 expression이 정확히 타입 $\tau$를 가질 것을 요구하며, 이 때의 연관 타입 환경변수 $\Gamma$를 반환합니다. 개발자가 특정 타입을 요구하였을 경우에 호출됩니다.
    \item $require(\Gamma,e,\tau)$: Requires the current expression to have the exact type $\tau$, and returns the associated type environment variable $\Gamma$ at that time. This is called when the developer has specific type requirements.
\end{itemize}

\section{Formal Rule of Subtype Inference}

\subsection{No Functions, Single Expression}
\subsubsection{Abstract Syntax}
% 이 접근법을 formal하게 정의하기 위한 type과 expression의 abstract syntax를 정의합니다.
We define the abstract syntax for types and expressions to formalize this approach:

\vspace{1em}

\begin{bnf}
    $\tau$ ::= $\epsilon$ | $\Z$
\end{bnf}

\begin{bnf}
    $e$ ::= \lett{x}{\tau}{e}{e}
    | $x$
    | $n$
    | \binop{e}{e}
    | \ternary{e}{e}{e}
\end{bnf}

\vspace{1em}

\subsubsection{Subtype and Required Type}

\newcommand{\required}[1]{\ensuremath{#1\text{ is required}}}
\newcommand{\nrequired}[1]{\ensuremath{#1\text{ is not required}}}
\newcommand{\forcerequire}[2]{\ensuremath{#1\Rightarrow#2}}

\[
    \epsilon <: \Z \quad \tau <: \tau
\]

\[
    \infer{
        \required{\tau}
    }{\tau=\epsilon}
\]

\[
    \infer{
        \forcerequire{\tau_1}{\tau_2}
    }{\required{\tau_2} \quad \tau_2 <: \tau_1}
\]

\subsubsection{Type Checking}
\newcommand{\checkrule}[4]{\[\infer{\checktype{\Gamma}{#1}{#2}{#3}}{
    \begin{array}{c}
        #4
    \end{array}
}\]}

\[\checktype{\Gamma}{x}{\Gamma(x)}{\emptyset}\]

\checkrule{n}{\Z}{\emptyset}{
    n\notin V_\epsilon
}

\checkrule{n}{\epsilon}{\emptyset}{
    n\in V_\epsilon
}

\checkrule{e}{\tau}{\Gamma_1}{
    \checktype{\Gamma}{e}{\tau'}{\Gamma_1} \quad
    \tau' <: \tau
}

\checkrule{\binop{e_1}{e_2}}{\Z}{\Gamma_1\cup\Gamma_2}{
    \checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \quad
    \checktype{\Gamma}{e_2}{\Z}{\Gamma_2}
}

\checkrule{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1\cup\Gamma_2\cup\Gamma_3}{
    \checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \\
    \checktype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad
    \checktype{\Gamma}{e_3}{\tau}{\Gamma_3}
}

\checkrule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
    \checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}
}

\checkrule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
    \checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x\notin Domain(\Gamma_2)
}

\checkrule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \\
    \checktype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x)=\tau
}

\subsubsection{Type Requiring}
\newcommand{\requirerule}[4]{\[\infer{\requiretype{\Gamma}{#1}{#2}{#3}}{
    \begin{array}{c}
        #4
    \end{array}}\]}

\requirerule{x}{\tau}{[x:\tau]}{
    \Gamma(x)=\tau' \quad \tau <: \tau'
}

\requirerule{n}{\epsilon}{\emptyset}{
    n\in V_\epsilon
}

\requirerule{e}{\tau}{\Gamma_1}{
    \nrequired{\tau} \quad \checktype{\Gamma}{e}{\tau}{\Gamma_1}
}

\requirerule{x}{\tau}{\Gamma_1}{
    \checktype{\Gamma}{x}{\tau'}{\Gamma_1} \quad \tau' <: \tau
}

\requirerule{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1}{
    \checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \\
    \requiretype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad
    \requiretype{\Gamma}{e_3}{\tau}{\Gamma_3}
}

\requirerule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
    \requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}
}

\requirerule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
    \requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x\notin Domain(\Gamma_2)
}

\requirerule{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \\
    \requiretype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x)=\tau
}

\subsection{With First-Class Functions}
% 함수가 있는 경우에 대한 추가로 문법을 정의합니다.

\newcommand{\arrowt}[2]{\ensuremath{{#1}\rightarrow{#2}}}

\subsubsection{Abstract Syntax}
We extend the abstract syntax to include functions:

\vspace{1em}

\begin{bnf}
    $\tau$ ::= $\cdots$ | \arrowt{\tau}{\tau}
\end{bnf}

\begin{bnf}
    $e$ ::= $\cdots$
    | \funct{x}{\tau}{e}
    | \apply{e}{e}
\end{bnf}

\vspace{1em}

\subsubsection{Subtype and Required Type}

\[\infer{
    \required{\arrowt{\tau_1}{\tau_2}}
}{\required{\tau_2}}\]

\[\infer{
    \arrowt{\tau_1}{\tau_2} <: \arrowt{\tau_3}{\tau_4}
}{
    \tau_3 <: \tau_1 \quad \tau_2 <: \tau_4
}\]

\subsubsection{Type Checking}
\checkrule{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \required{\tau_1} \quad
    \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}
}

\checkrule{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \nrequired{\tau_1} \\
    \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x\notin Domain(\Gamma_1)
}

\checkrule{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \forcerequire{\tau}{\tau_1} \quad
    \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad
    \Gamma_1(x)=\tau_1
}

\checkrule{\apply{e_1}{e_2}}{\tau_2}{\Gamma_1\cup\Gamma_2}{
    \requiretype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1} \quad
    \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_2}
}

\subsubsection{Type Requiring}
\requirerule{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \required{\tau_1} \quad
    \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}
}

\requirerule{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \nrequired{\tau_1} \\
    \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x\notin Domain(\Gamma_1)
}

\requirerule{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}{
    \forcerequire{\tau}{\tau_1} \quad
    \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad
    \Gamma_1(x)=\tau_1
}

\requirerule{\apply{e_1}{e_2}}{\tau_2}{\Gamma_2\cup\Gamma_3}{
    \checktype{\Gamma}{e_1}{\arrowt{\tau_3}{\tau_4}}{\Gamma_1} \quad \tau_1 <: \tau_3 \\
    \requiretype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_2} \quad \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_3}
}



\section{Applying to Translation}

\subsection{Propositions}

% 위에서 정의한 rule대로, 아래와 같은 명제를 제시합니다.
We propose the following propositions based on the rules defined above:

% C 코드 $e$가 well-typed이다. $e'$은 $e$의 코드에서 타입 선언부에 enum type의 이름이 사용된 모든 변수의 선언부를 $\epsilon$으로 수정한 코드이다. 이 때,
% 1. check(empty, e')가 모든 rule을 pass한다면, enum type은 정수 타입의 subtype으로 변환할 수 있음이 검증된다.
% 2. checktype{}{}{}{...}라고 하자. 모든 x in domain(gamma1)에 대하여 x의 선언부 타입을 gamma1(x)로 수정한 expression e''은 well-typed이다.

Let $e$ be a well-typed C code. Let $e'$ be the code obtained by modifying the declaration of all variables in $e$ where the name of the enum type is used in the type declaration to $\epsilon$. Then:
\begin{enumerate}
    \item If $check(\emptyset, e')$ passes all rules, it is verified that the enum type can be translated as a subtype of the integer type.
    \item Let $\checktype{\emptyset}{e'}{\tau}{\Gamma_1}$. If we modify the declaration of the type of every variable $x$ in $\Gamma$ to $\Gamma(x)$ to obtain the expression $e''$, then $e''$ is well-typed.
\end{enumerate}

% 위의 명제는 formal한 증명을 제공하지 않습니다. 대신, 이 명제가 올바르게 작동하는지 확인하기 위한 예시를 제공합니다. 이 예시들은 앞서 정의한 formal rule이 의도대로 작동함을 확인하는 데 사용됩니다.
This report does not present a rigorous proof of the propositions. Instead, we provide examples to verify that these propositions work correctly. These examples serve to confirm that the formal rules defined earlier function as intended.

\subsection{Examples}

% 해당 rule이 잘 작동하는지 확인하기 위한 예시를 제시합니다. epsilon이 0 값을 포함한다고 가정했을 때, 아래와 같은 코드를 생각해봅시다:
We consider the following code, assuming that $\epsilon$ includes the value 0:
\[
\lett{x}{\Z}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

% 우리가 정상적인 enum translation을 위하여 달성해야 하는 목표를 생각해봅니다. y의 타입은 epsilon으로 지정되었으므로, 개발자가 enum 타입으로 의도했다고 받아들여야 합니다. 해당 코드가 type error 없이 작동하기 위해서 x가 epsilon 타입이라고 subtype 추정을 해야 합니다. 이 추정은 x에 0이 대입되었으므로 올바릅니다. z는 epsilon 타입으로 지정되지 않았고 이외에 epsilon 타입과 연관된 사용이 없었으므로, 0으로 선언되었음에도 epsilon 타입으로 추정하지 않아야 합니다.
Consider the goal we need to achieve for normal enum translation: since the type of $y$ is specified as $\epsilon$, we should assume that the developer intended it to be an enum type. To ensure that this code works without type errors, we need to perform subtype inference on $x$ to be of type $\epsilon$. This inference is valid since $x$ is assigned the value 0. However, $z$ is not specified as an $\epsilon$ type and has no other associations with $\epsilon$, so it should not be inferred as an $\epsilon$ type even though it is declared as 0.

% 앞서 정의한 formal rule을 적용해보면, $x$만 $\epsilon$ 타입에 연관된다는 사실을 어렵지 않게 알 수 있습니다.
Applying the formal rules defined earlier, we can easily determine that only $x$ is associated with the $\epsilon$ type.
% 연관된 변수의 선언부를 수정함으로써, 다음과 같이 enum 타입이 잘 적용된 well-typed expression을 얻을 수 있습니다:
By modifying the declaration of the associated variable, we obtain a well-typed expression with the enum type applied correctly:
\[
\lett{x}{\epsilon}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

% 앞서 언급한 예시를 통해, 함수가 적용된 경우에도 이 접근법이 잘 작동함을 확인할 수 있습니다. 예를 들어, 아래와 같은 코드를 생각해봅시다:
We can confirm that this approach works well even when functions are applied, as shown in the following example:

\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\Z}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

% 이 코드에서, ctoi 함수는 epsilon 타입의 파라미터를 받아 3을 곱한 값을 반환합니다. green은 Z 타입으로 선언되었지만, ctoi 함수에 적용되므로 epsilon 타입과 연관됩니다. 따라서, green은 epsilon 타입으로 추정되어야 합니다. 이 경우에도, formal rule을 적용하면 올바르게 추정할 수 있습니다.
In this code, the \ensuremath{ctoi} function takes a parameter of type $\epsilon$ and returns the value multiplied by 3. Although \ensuremath{green} is declared as type \ensuremath{\Z}, it is associated with the $\epsilon$ type when applied to the \ensuremath{ctoi} function. Therefore, \ensuremath{green} should be inferred as type $\epsilon$. Again, applying the formal rules allows us to make the correct inference, resulting in the following well-typed expression:

\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\epsilon}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

% 이와 같은 예시를 통해, formal rule이 의도대로 작동함을 확인할 수 있습니다. 이 접근법은 C 코드에서 enum 타입을 Rust의 enum 타입으로 변환할 수 있는지 여부를 판단하고, 변환이 가능할 경우 integer type의 alias 대신에 Rust의 enum으로 변환하는 데 유용합니다.
These examples demonstrate that the formal rules work as intended. This approach is useful for determining whether a C code's enum type can be translated to a Rust enum type and, if feasible, replacing the integer type alias with a Rust enum.

\section{Conclusion}
% 무엇을 달성했는가
In this report, we have proposed a novel approach to improve C2Rust's enum translation by introducing subtype inference. This approach allows us to determine whether a C enum can be translated to a Rust enum and, if feasible, replaces the integer type alias with a Rust enum. By leveraging the value safety and expressiveness of Rust's enums, we enhance the translation process and ensure that the resulting code is idiomatic and well-typed.

% 어떤 효과가 있는가
The proposed approach has several benefits. First, it increases the accuracy of the translation process by ensuring that the types are correctly inferred and associated. This leads to fewer type errors and a smoother migration from C to Rust. Second, by replacing integer type aliases with Rust enums, we improve the readability and maintainability of the code. Developers can more easily understand the intent behind the code when enums are used instead of generic integer types.

% 어떤 것이 개선되어야 하는가
% 본 연구는 strict한 type system을 기반으로 접근하였으므로, 실제로는 enum 타입으로 해석할 수 있는 경우에도 변환을 실패할 수 있습니다. 예를 들어, 아래와 같은 매우 흔한 패턴의 C 코드가 있다고 가정해봅시다:

However, this research is based on a strict type system, so it may fail to translate even in cases where it can be interpreted as an enum type. For example, consider the following common C code pattern:

\begin{lstlisting}[language=C]
enum Day {
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
};

enum Day next_day(enum Day day) {
    return (day + 1) % 7;
}
\end{lstlisting}

% 이 코드는 C에서 enum 타입을 사용하여 요일을 표현하고, 다음 요일을 계산하는 함수입니다. 이 경우 enum으로의 변환이 성공적이려면 return 값이 항상 0부터 6 사이의 값임을 도출해낼 수 있어야 합니다. 하지만 type system 만으로는 이를 보장할 수 없습니다. 따라서, 본 연구에서 제시한 formal rule은 이러한 경우에 enum 타입으로의 변환을 실패합니다.

This code uses an enum type in C to represent days of the week and calculates the next day. For a successful translation to an enum, it must be deduced that the return value is always between 0 and 6. However, the type system alone cannot guarantee this. Therefore, the formal rules proposed in this research will fail to translate this case to an enum type.

% 이러한 경우를 해결하기 위해서는, 정수 타입의 범위를 추론하는 추가적인 분석이 필요합니다. 사칙연산이 있는 경우에 enum 타입이 아니라고 단정짓는 것이 아니라, 그 expression이 가질 수 있는 값의 constraint를 추론하여 enum 타입으로 변환할 수 있는지 여부를 판단해야 합니다. 이러한 분석을 통해, C 코드에서 enum 타입을 Rust의 enum 타입으로 변환할 수 있는 경우를 더 많이 포착할 수 있을 것입니다.

To address such cases, additional analysis is needed to infer the range of integer types. Instead of concluding that an expression with arithmetic operations cannot be an enum type, we should deduce the constraints on the values that the expression can take and determine whether it can be translated to an enum type. This analysis would allow us to capture more cases where a C code's enum type can be translated to a Rust enum type.

\end{document}