\documentclass[peerreview, 10pt]{IEEEtran}

\usepackage{times}
\usepackage{graphicx}
\usepackage{proof}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{simplebnf}
\usepackage[margin=0.75in]{geometry}
\usepackage{framed}

\setlength{\jot}{6pt}

\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinelanguage{Rust}{
  keywords={break, const, continue, crate, else, enum, extern, false, fn, for, 
if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, 
static, struct, super, trait, true, type, unsafe, use, where, while, as, async, 
await, dyn},
  keywordstyle=\color{magenta},
  ndkeywords={u8, u16, u32, u64, usize, i8, i16, i32, i64, isize, f32, f64, str,
 String, char, bool, Option, Result, Some, None, Ok, Err, Box, Vec},
  ndkeywordstyle=\color{blue},
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{codegreen}\ttfamily,
  stringstyle=\color{codepurple}\ttfamily,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\lete}[3]{\ensuremath{\mathsf{let}\ #1\ \mathsf{=}\ #2\ \mathsf{in}\ #3}}
\newcommand{\lett}[4]{\ensuremath{\mathsf{let}\ #1\mathsf{:}\,#2\ \mathsf{=}\ #3\ \mathsf{in}\ #4}}
\newcommand{\binop}[2]{\ensuremath{#1\ \mathsf{\oplus}\ #2}}
\newcommand{\ternary}[3]{\ensuremath{\mathsf{if0}\ #1\ \mathsf{then}\ #2\ \mathsf{else}\ #3}}
\newcommand{\func}[2]{\ensuremath{\lambda #1.#2}}
\newcommand{\funct}[3]{\ensuremath{\lambda #1\mathsf{:}\,#2.#3}}
\newcommand{\apply}[2]{\ensuremath{#1\ #2}}
\newcommand{\raw}[1]{\ensuremath{#1\mathsf{.raw}}}
\newcommand{\arrowt}[2]{\ensuremath{{#1}\rightarrow{#2}}}
\newcommand{\checktype}[4]{\ensuremath{{check}(#1,\,#2)=(#3,\,#4)}}
\newcommand{\requiretype}[4]{\ensuremath{{require}(#1,\,#2,\,#3)=#4}}
\newcommand{\required}[1]{\ensuremath{#1\text{ is required}}}
\newcommand{\nrequired}[1]{\ensuremath{#1\text{ is not required}}}
\newcommand{\forcerequire}[2]{\ensuremath{#1\Rightarrow#2}}
\newcommand{\domain}[1]{\ensuremath{\text{Domain}(#1)}}

\begin{document}

\title{Enhancing C-to-Rust Translation with Subtype Inference for Enum Types}

\author{
    \IEEEauthorblockN{Minwook Lee}
    \IEEEauthorblockA{ryan-lee@kaist.ac.kr}
}

\maketitle

\begin{abstract}
Automatic C-to-Rust translation is a promising way to improve the reliability of legacy C software. However, the existing C2Rust translator primarily performs direct syntactic conversion, which often fails to produce idiomatic Rust code and thus undermines the goal of safer, more reliable software.

For example, in C an \texttt{enum} is effectively just an integer type and does not ensure that a variable only holds one of its defined variant values. Consequently, C2Rust translates C enums as integers in Rust, using type aliases and constants for the variants. In contrast, Rust's \texttt{enum} type enforces that only valid variant values can be assigned and supports pattern matching for variant-specific behavior. Ideally, a translation tool should convert C enums into real Rust enums to take advantage of these safety features.

In this report, we introduce a subtype inference technique to enhance C2Rust's handling of enum types. This approach analyzes the usage of an enum in the C code to determine if it can safely be represented as a Rust enum. If so, the translator replaces the integer alias with a proper Rust enum definition. This enhancement leverages Rust's safety and expressiveness, yielding translated code that is more idiomatic and type-safe.
\end{abstract}

\section{Background and Motivation}

\subsection{Enumeration Types in C and Rust}
In C, an \texttt{enum} is essentially a set of named integer constants; the language does not enforce that an enum variable holds only the defined variant values. Each enumerator is assigned an integer (either explicitly or by default in sequence), and different enum types can even share the same underlying values. This means a program can assign an integer value to an enum variable even if that value doesn't correspond to any defined variant. Consider the following code example:

\begin{lstlisting}[language=C]
enum Color {
    r, // 0
    g, // 1
    b = 3
};

int main() {
    enum Color color = r;
    color = 4; // no error
    return 0;
}
\end{lstlisting}

In this C code, the \texttt{enum Color} defines three variants, where \texttt{r} and \texttt{g} are implicitly mapped to 0 and 1, and \texttt{b} is explicitly mapped to 3. In the \texttt{main} function, the variable \texttt{color} is declared as type \texttt{Color} and initialized to \texttt{r}. However, the code then assigns \texttt{color = 4}, which is not one of the defined variants, and C allows this without any error. This illustrates that C enums do not provide value safety.

In contrast, Rust's \texttt{enum} type ensures value safety and is more expressive. Each variant in a Rust enum is distinct and cannot be conflated with an unrelated integer value. Moreover, Rust allows pattern matching on enums, enabling clear and type-safe differentiation of variants in code. The following Rust example demonstrates these properties:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, // 0
    G, // 1
    B = 3,
}

fn main() {
    use std::mem::transmute;

    assert_eq!(Color::R as i32, 0);
    assert!(matches!(
        unsafe { transmute::<i32, Color>(0) },
        Color::R
    ));
    // let color: Color = 4; // error
    // let color: Color = 4 as Color; // error
    let color: Color = unsafe { transmute::<i32, Color>(4) }; // Undefined behavior
}
\end{lstlisting}

Note that Rust enums are a form of algebraic data type and can be more expressive (for example, variants can hold associated data), but here we restrict our focus to simple C-like enums with integer values. In the Rust code above, the enum \texttt{Color} has three variants (\texttt{R}, \texttt{G}, and \texttt{B}) corresponding to 0, 1, and 3 respectively. In \texttt{main}, the variable \texttt{color} is of type \texttt{Color} and is initialized to \texttt{Color::R}. Any attempt to assign an out-of-range value (such as \texttt{4}) to \texttt{color} results in a compile-time error. This demonstrates that Rust enums guarantee an enum variable cannot hold values outside its defined variants.

\subsection{C2Rust's Enum Translation}

C2Rust is a tool for translating C code to Rust. Although it can handle enums, in practice C2Rust translates each C enum into a Rust integer type alias (with constants for the variants) rather than using a proper Rust enum type. This means it fails to leverage Rust's value safety and expressiveness for enums. The limitation stems from C2Rust's reliance on straightforward syntactic transformations.

For example, consider the C enumeration below and how C2Rust translates it:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};
\end{lstlisting}

C2Rust produces the following Rust code:

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;
\end{lstlisting}

In this output, the enum is essentially lost: \texttt{Color} is defined as an alias for \texttt{libc::c\_uint}, and each variant is a constant of that type. The translated code behaves like an untyped integer, not leveraging Rust's enum features or value checking.

In C, an enum type is effectively interchangeable with an integer type (it is just a labeled alias), so C2Rust's current translation is technically faithful as a direct transformation. However, if a developer explicitly uses an enum type name in a variable or function declaration, it implies an intention that the variable should only take on values from that enum's set of variants. If we can verify from the code that this intention is respected (i.e., only valid variant values are ever assigned to that variable), then it would be more appropriate for the translated Rust code to use a real enum type instead of a plain integer.

For these reasons, we propose to augment C2Rust with a subtype inference mechanism for enums. This mechanism determines if a given C enum's usage is consistent with a Rust enum's constraints, and if so, translates it into an actual Rust enum (replacing the integer alias). The goal is to produce translated code that fully benefits from Rust's safety features and clarity.

\section{Approach}

\subsection{Na\"ive Translation}

A straightforward idea would be to always translate a C enum into a Rust enum in the output, as long as doing so does not break the code's correctness. For example, consider the following C code and how C2Rust currently translates it:

\begin{lstlisting}[language=C]
enum Color {
    r, g, b
};

int ctoi(const enum Color color) {
    switch (color) {
        case r:
            return 0x0000ff;
        case g:
            return 0x00ff00;
        case b:
            return 0xff0000;
    }
    return -1;
}
\end{lstlisting}

\begin{lstlisting}[language=Rust]
pub type Color = libc::c_uint;
pub const b: Color = 2;
pub const g: Color = 1;
pub const r: Color = 0;

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color as libc::c_uint {
        0 => return 0xff as libc::c_int,
        1 => return 0xff00 as libc::c_int,
        2 => return 0xff0000 as libc::c_int,
        _ => {}
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

C2Rust's translation above leaves \texttt{Color} as an alias for \texttt{c\_uint}. Suppose instead we manually alter the translation to use a Rust enum for \texttt{Color}:

\begin{lstlisting}[language=Rust]
#[repr(C)]
enum Color {
    R, G, B
}

unsafe fn ctoi(color: Color) -> libc::c_int {
    match color {
        Color::R => return 0xff as libc::c_int,
        Color::G => return 0xff00 as libc::c_int,
        Color::B => return 0xff0000 as libc::c_int,
    }
    return -(1 as libc::c_int);
}
\end{lstlisting}

In this instance, replacing the alias with a real Rust enum works correctly. As long as the C code never introduces invalid values for \texttt{Color}, translating it directly to a Rust enum is sound. However, now consider an additional piece of code added to this program:

\begin{lstlisting}[language=C, label=lst:example]
// ...

int foo() {
    const int green = 1;
    return ctoi(green);
}
\end{lstlisting}

\begin{lstlisting}[language=Rust]
// ...

fn foo() -> libc::c_int {
    use std::mem::transmute;
    let green: libc::c_uint = 1;
    // return ctoi(green); // error
    // return ctoi(green as Color); // error
    return ctoi(unsafe { 
        transmute::<libc::c_uint, Color>(green) 
    }); // only workaround, but unsafe
}
\end{lstlisting}

In the \texttt{foo} function above, C allows an implicit conversion: the constant integer \texttt{green} (value 1) is passed to \texttt{ctoi}, which expects an enum \texttt{Color}. Rust, however, does not permit implicitly or explicitly casting an integer to an enum type. As a result, calling \texttt{ctoi(green)} would not compile in Rust, even an attempt like \texttt{ctoi(green as Color)} is disallowed. Only a workaround using \texttt{transmute} allows passing \texttt{green} to \texttt{ctoi}, but this is unsafe and can lead to undefined behavior if \texttt{green} does not correspond to a valid \texttt{Color} variant. This scenario highlights why C2Rust sticks to integer types for enums; a na\"ive direct conversion would break here. We need a more nuanced approach to handle such cases. To address this, we propose a technique called \emph{subtype inference}.

\subsection{Subtype Inference}

Our approach introduces the concept of treating the C enum type as a subtype of a general integer type. In other words, we assume a C enum $\epsilon$ should allow only the values defined by its variants (making it, conceptually, a subset of $\mathbb{Z}$). Under this interpretation, we enforce that any variable declared with type $\epsilon$ can only be assigned one of the enum's variant values. In C, this property is not enforced by the compiler (any integer can be assigned), whereas in Rust the compiler does enforce it (an enum variable can only be one of its variants).

With subtype inference, we analyze the program to infer whether an enum type is consistently used in a restricted way (only holding its variant values). If so, we consider that enum to be a subtype of the integer type, meaning it effectively behaves like an integer with a limited range. We then translate it as a Rust enum. This analysis requires examining every usage of the enum in the C code and checking that any value assigned to a variable of that type is indeed one of the defined variant values.

For a concrete illustration, revisit the earlier \texttt{foo} example. We assume that whenever the code explicitly uses the enum's name in a type annotation, it is intended to truly be of that enum type. Under this assumption:
\begin{itemize}
    \item The parameter \texttt{c} of function \texttt{ctoi} is declared as type \texttt{Color}, so we treat it as genuinely meant to be a \texttt{Color}.
    \item In the body of \texttt{foo}, the variable \texttt{green} is passed to \texttt{ctoi}. This usage suggests that \texttt{green} should be considered a \texttt{Color} as well (since it is being used where a \texttt{Color} is expected).
    \item We accordingly change \texttt{green}'s declaration from \texttt{const int green = 1;} to \texttt{const Color green = 1;}.
    \item We then verify that this change does not introduce any type errors. In this case, the initializer value \texttt{1} is indeed one of the defined \texttt{Color} variants (assuming \texttt{r=0}, \texttt{g=1}, \texttt{b=3} as earlier), so the assignment is valid under the new type.
\end{itemize}

If we can apply such transformations for all instances where the enum is used (and none of them produce a type error), then the C enum in question can safely be translated into a Rust enum. In the next section, we formalize this approach with a formal grammar and inference rules.

\section{Formal Definitions and Assumptions}

\subsection{Notation}

We introduce the following notation for our formalization:
\begin{enumerate}
    \item Let $\epsilon$ denote the particular enum type under consideration for translation.
    \item Let $V_\epsilon$ be the set of all integer values corresponding to the variants of $\epsilon$ (i.e., the values that $\epsilon$ can take).
\end{enumerate}

\subsection{Assumptions}
Our approach relies on several assumptions:
\begin{enumerate}
    \item The C code is well-typed (we assume no type errors in the input program), and the type of every variable can be determined.
    \item If the enum type's name $\epsilon$ is explicitly used in a variable or parameter declaration in the C code, we assume the type of that variable is intended to be $\epsilon$.
    \item For simplicity, assume that all parameter and variable identifier names are distinct (no naming collisions).
    \item We maintain an associated type environment $\Gamma$ (with elements stored in a set $TEnv$) that records variables and their associated required types.
\end{enumerate}

\subsection{Type Checking and Requirement Functions}
We define two functions to formalize the checking of expressions and enforcement of required types:
\begin{itemize}
    \item $check(\Gamma, e)$: Performs standard type checking on expression $e$ under environment $\Gamma$. It returns the inferred type $\tau$ of $e$ and an updated associated type environment $\Gamma$. This function is used in the general case where there are no special developer requirements on types.
    \item $require(\Gamma, e, \tau)$: Checks expression $e$ under environment $\Gamma$ with the requirement that $e$'s type must be exactly $\tau$. It returns the associated type environment $\Gamma$ after enforcing this requirement. This function is used when a specific type is expected for an expression (for example, due to an explicit annotation or context).
\end{itemize}

\section{Formal Rules for Subtype Inference}

\subsection{Basic Expression Language (No Functions)}
\subsubsection{Abstract Syntax}
We first define an abstract syntax for a simple language of expressions (without functions) to model our approach:

\vspace{0.5em}
\begin{bnf}
    $\tau$ ::= $\epsilon$ | $\Z$
\end{bnf}

\begin{bnf}
    $e$ ::= \lett{x}{\tau}{e}{e} 
    | $x$ 
    | $n$ 
    | \binop{e}{e} 
    | \ternary{e}{e}{e}
\end{bnf}
\vspace{0.5em}

\subsubsection{Subtype, Required Type, and Type Environment Rules}
We treat the enum type $\epsilon$ as a subtype of the integer type $\Z$. We also introduce a notion of a ``required" type for enforcing enum types in certain contexts. The formal rules for subtyping, required types, and type environments are given in Figure~\ref{fig:subtype-required-rules}. The definition of the greatest lower bound type, $\tau_1\sqcap\tau_2$, is in Appendix.

\begin{figure}[ht]
\centering
\begin{framed}
    \[
\begin{gathered}
\begin{array}{rcrc}
\text{\textsc{Sub-Epsilon:}} &\quad \epsilon <: \Z &
\text{\textsc{Req-Enum:}} &\quad \infer{\required{\tau}}{\tau = \epsilon} \\
\text{\textsc{Sub-Refl:}} &\quad \tau <: \tau &
\text{\textsc{Force-Req:}} &\quad \infer{\forcerequire{\tau_1}{\tau_2}}{\required{\tau_2}\quad \tau_2 <: \tau_1}
\end{array}\\
\text{\textsc{TEnv-Union:}} \quad \Gamma_1 \cup \Gamma_2=\Gamma \text{ where } \Gamma(x)=
\begin{cases}
    \Gamma_1(x)\sqcap\Gamma_2(x) & \text{if } x \in \text{Domain}(\Gamma_1) \cap \text{Domain}(\Gamma_2)\\
    \Gamma_1(x) & \text{if } x \in \text{Domain}(\Gamma_1) \\
    \Gamma_2(x) & \text{if } x \in \text{Domain}(\Gamma_2) 
\end{cases}
\end{gathered}
    \]
\end{framed}
\caption{Subtype relation and required-type rules (for the base language). Rule \textsc{Sub-Epsilon} declares the enum type $\epsilon$ to be a subtype of the integer type $\Z$, and \textsc{Sub-Refl} allows any type to be a subtype of itself. Rule \textsc{Req-Enum} tags $\epsilon$ as a required type (indicating that contexts expecting this type must enforce it), and \textsc{Force-Req} states that if $\tau_2$ is required and $\tau_2 <: \tau_1$, then $\tau_1$ can be forced to a required subtype $\tau_2$. 
Finally, \textsc{TEnv-Union} defines how to combine two type environments $\Gamma_1$ and $\Gamma_2$ into a new environment $\Gamma$, resolving conflicts by taking the more specific type when both environments define the same variable.}
\label{fig:subtype-required-rules}
\end{figure}

\subsubsection{Type Checking}
The type checking rules for expressions (without functions) are given in Figure~\ref{fig:type-checking-rules}.

\begin{figure*}[ht]
\normalsize
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Check-Var:}} &\quad \checktype{\Gamma}{x}{\Gamma(x)}{\emptyset} \\
\text{\textsc{Check-ConstNonEnum:}} &\quad \infer{\checktype{\Gamma}{n}{\Z}{\emptyset}}{n \notin V_\epsilon} \\
\text{\textsc{Check-ConstEnum:}} &\quad \infer{\checktype{\Gamma}{n}{\epsilon}{\emptyset}}{n \in V_\epsilon} \\
\text{\textsc{Check-Subsumption:}} &\quad \infer{\checktype{\Gamma}{e}{\tau}{\Gamma_1}}{\checktype{\Gamma}{e}{\tau'}{\Gamma_1} \quad \tau' <: \tau} \\
\text{\textsc{Check-BinOp:}} &\quad \infer{\checktype{\Gamma}{\binop{e_1}{e_2}}{\Z}{\Gamma_1 \cup \Gamma_2}}{\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \quad \checktype{\Gamma}{e_2}{\Z}{\Gamma_2}} \\
\text{\textsc{Check-Ternary:}} &\quad \infer{\checktype{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1 \cup \Gamma_2 \cup \Gamma_3}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \quad
\checktype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad \checktype{\Gamma}{e_3}{\tau}{\Gamma_3}
\end{array}
} \\
\text{\textsc{Check-Let-Req:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}\quad
(\Gamma_2\cup[x:\tau_1])(x)=\tau_1
\end{array}
} \\
\text{\textsc{Check-Let-NoReq:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\checktype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x \notin \text{Domain}(\Gamma_2)
\end{array}
} \\
\text{\textsc{Check-Let-Force:}} &\quad \infer{\checktype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \quad
\checktype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x) = \tau
\end{array}
}
\end{align*}
\end{framed}
\caption{Type checking rules for the base language (no functions). \textsc{Check-Var} retrieves a variable's type from the environment. \textsc{Check-ConstNonEnum} and \textsc{Check-ConstEnum} classify a numeric literal as type $\Z$ or $\epsilon$ depending on whether its value belongs to $V_\epsilon$. \textsc{Check-Subsumption} allows an expression of a subtype to be used as a supertype. \textsc{Check-BinOp} and \textsc{Check-Ternary} ensure that binary operations use integer operands and that a ternary conditional has an integer condition and consistent branch result types. Finally, \textsc{Check-Let-Req}, \textsc{Check-Let-NoReq}, and \textsc{Check-Let-Force} handle let-bindings: enforcing required types, handling the absence of a requirement, and forcing a required subtype, respectively.}
\label{fig:type-checking-rules}
\end{figure*}

\subsubsection{Type Requiring}
The rules for requiring (asserting) specific types are given in Figure~\ref{fig:type-requiring-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Require-Var-Env:}} &\quad \requiretype{\Gamma}{x}{\tau}{[x:\tau]} \\
\text{\textsc{Require-ConstEnum:}} &\quad \infer{\requiretype{\Gamma}{n}{\epsilon}{\emptyset}}{n \in V_\epsilon} \\
\text{\textsc{Require-Subsumption:}} &\quad \infer{\requiretype{\Gamma}{e}{\tau}{\Gamma_1}}{\checktype{\Gamma}{e}{\tau'}{\Gamma_1} \quad \tau' <: \tau} \\
\text{\textsc{Require-Expr-NoReq:}} &\quad \infer{\requiretype{\Gamma}{e}{\tau}{\Gamma_1}}{\nrequired{\tau} \quad \checktype{\Gamma}{e}{\tau}{\Gamma_1}} \\
\text{\textsc{Require-Ternary:}} &\quad \infer{\requiretype{\Gamma}{\ternary{e_1}{e_2}{e_3}}{\tau}{\Gamma_1\cup \Gamma_2 \cup \Gamma_3}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\Z}{\Gamma_1} \quad
\requiretype{\Gamma}{e_2}{\tau}{\Gamma_2} \quad \requiretype{\Gamma}{e_3}{\tau}{\Gamma_3}
\end{array}
} \\
\text{\textsc{Require-Let-Req:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\required{\tau_1} \quad \requiretype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2}\quad
(\Gamma_2\cup[x:\tau_1])(x)=\tau_1
\end{array}
} \\
\text{\textsc{Require-Let-NoReq:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\nrequired{\tau_1} \quad \checktype{\Gamma}{e_1}{\tau_1}{\Gamma_1} \\
\requiretype{\Gamma[x:\tau_1]}{e_2}{\tau_2}{\Gamma_2} \quad x \notin \text{Domain}(\Gamma_2)
\end{array}
} \\
\text{\textsc{Require-Let-Force:}} &\quad \infer{\requiretype{\Gamma}{\lett{x}{\tau_1}{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{
\begin{array}{c}
\forcerequire{\tau_1}{\tau} \quad \requiretype{\Gamma}{e_1}{\tau}{\Gamma_1} \quad
\requiretype{\Gamma[x:\tau]}{e_2}{\tau_2}{\Gamma_2} \quad \Gamma_2(x) = \tau
\end{array}
}
\end{align*}
\end{framed}
\caption{Type requirement (``require'') rules for the base language. \textsc{Require-Var-Env} adds a variable to the environment with a required type (if that required type $\tau$ is a subtype of the variable's original type $\tau'$). \textsc{Require-ConstEnum} asserts that a numeric literal has type $\epsilon$ if its value is in $V_\epsilon$. \textsc{Require-Expr-NoReq} processes an expression normally when no special requirement applies. \textsc{Require-Subsumption} handles requiring a variable expression to have a certain type by checking it and ensuring the actual type is a subtype of the required type. \textsc{Require-Ternary} enforces that both branches of a conditional expression meet the required type. Finally, \textsc{Require-Let-Req}, \textsc{Require-Let-NoReq}, and \textsc{Require-Let-Force} impose type requirements in let-binding contexts analogously to the type checking rules.}
\label{fig:type-requiring-rules}
\end{figure*}

\subsection{Extension: First-Class Functions}
\subsubsection{Abstract Syntax}
We now extend the language syntax to include first-class functions:

\vspace{0.5em}
\begin{bnf}
    $\tau$ ::= $\cdots$ | \arrowt{\tau}{\tau}
\end{bnf}

\begin{bnf}
    $e$ ::= $\cdots$ 
    | \funct{x}{\tau}{e} 
    | \apply{e}{e}
\end{bnf}
\vspace{0.5em}

This extension adds function types ($\tau_1 \to \tau_2$), lambda abstractions (anonymous functions), and function application to our language.

\subsubsection{Subtype and Required Type}
The additional rules for subtyping and required types with function types are shown in Figure~\ref{fig:function-subtype-rules}.

\begin{figure}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Req-Arrow:}} &\quad \infer{\required{\arrowt{\tau_1}{\tau_2}}}{\required{\tau_2}} \\
\text{\textsc{Sub-Arrow:}} &\quad \infer{\arrowt{\tau_1}{\tau_2} <: \arrowt{\tau_3}{\tau_4}}{\tau_3 <: \tau_1 \quad \tau_2 <: \tau_4}
\end{align*}
\end{framed}
\caption{Additional subtyping and requirement rules for function types. \textsc{Req-Arrow} marks a function type as required if its return type is required (i.e., if $\tau_2$ must be $\epsilon$, then the function type $\tau_1 \to \tau_2$ is considered required). \textsc{Sub-Arrow} is the subtyping rule for function types: $\tau_1 \to \tau_2$ is a subtype of $\tau_3 \to \tau_4$ if $\tau_3$ is a subtype of $\tau_1$ (parameter types are contravariant) and $\tau_2$ is a subtype of $\tau_4$ (return types are covariant).}
\label{fig:function-subtype-rules}
\end{figure}

\subsubsection{Type Checking}
The type checking rules for function abstractions and application are shown in Figure~\ref{fig:function-check-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Check-Lambda-Req:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\required{\tau_1} \quad \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}\quad
(\Gamma_1\cup[x:\tau_1])(x)=\tau_1
\end{array}} \\
\text{\textsc{Check-Lambda-NoReq:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\nrequired{\tau_1} \quad
\checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x \notin \text{Domain}(\Gamma_1)
\end{array}
} \\
\text{\textsc{Check-Lambda-Force:}} &\quad \infer{\checktype{\Gamma}{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\forcerequire{\tau}{\tau_1} \quad \checktype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad \Gamma_1(x) = \tau_1
\end{array}
} \\
\text{\textsc{Check-Apply:}} &\quad \infer{\checktype{\Gamma}{\apply{e_1}{e_2}}{\tau_2}{\Gamma_1 \cup \Gamma_2}}{\checktype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1} \quad \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_2}}
\end{align*}
\end{framed}
\caption{Extended type checking rules to support first-class functions. The \textsc{Check-Lambda-*} rules handle type checking of lambda (anonymous function) expressions under three scenarios: when the parameter's type is required (\textsc{Check-Lambda-Req}), when the parameter has no special requirement (\textsc{Check-Lambda-NoReq}), and when a required subtype must be enforced for the parameter (\textsc{Check-Lambda-Force}). \textsc{Check-Apply} checks a function application by first ensuring the function expression has an arrow type and then requiring the argument expression to have the function's parameter type.}
\label{fig:function-check-rules}
\end{figure*}

\subsubsection{Type Requiring}
Finally, the requirement rules for function-related expressions are given in Figure~\ref{fig:function-require-rules}.

\begin{figure*}[ht]
\centering
\begin{framed}
\begin{align*}
\text{\textsc{Require-Lambda-Req:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\required{\tau_1} \quad \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1}\quad
(\Gamma_1\cup[x:\tau_1])(x)=\tau_1
\end{array}} \\
\text{\textsc{Require-Lambda-NoReq:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau_1}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\nrequired{\tau_1} \quad
\requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad x \notin \text{Domain}(\Gamma_1)
\end{array}
} \\
\text{\textsc{Require-Lambda-Force:}} &\quad \infer{\requiretype{\Gamma}{\funct{x}{\tau}{e}}{\arrowt{\tau_1}{\tau_2}}{\Gamma_1}}{
\begin{array}{c}
\forcerequire{\tau}{\tau_1} \quad \requiretype{\Gamma[x:\tau_1]}{e}{\tau_2}{\Gamma_1} \quad \Gamma_1(x) = \tau_1
\end{array}
} \\
\text{\textsc{Require-Apply:}} &\quad \infer{\requiretype{\Gamma}{\apply{e_1}{e_2}}{\tau_2}{\Gamma_2 \cup \Gamma_3}}{
\begin{array}{c}
\checktype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_3}}{\Gamma_1} \quad \forcerequire{\tau_3}{\tau_2}\\
\requiretype{\Gamma}{e_1}{\arrowt{\tau_1}{\tau_2}}{\Gamma_2} \quad \requiretype{\Gamma}{e_2}{\tau_1}{\Gamma_3}
\end{array}
}
\end{align*}
\end{framed}
\caption{Extended requirement rules for first-class functions. \textsc{Require-Lambda-Req} enforces an expected parameter type on a lambda expression (if the parameter's type is required to be $\epsilon$). \textsc{Require-Lambda-NoReq} handles a lambda with no special parameter requirement (ensuring the parameter is not inadvertently inferred to a required type elsewhere). \textsc{Require-Lambda-Force} forces a lambda's parameter to have a specific subtype if needed. \textsc{Require-Apply} imposes requirements when a function is applied: it first checks that the function has a suitable arrow type (and may refine the expected parameter type $\tau_1$ if it was too general), and then requires the argument to have that parameter type $\tau_1$.}
\label{fig:function-require-rules}
\end{figure*}

\section{Applying to Translation}

\subsection{Propositions}

Based on the above rules, we formulate two propositions about translating an enum type using this approach:

Let $e$ be a well-typed C program, and let $e'$ be the program obtained by changing the declared type of every variable (and parameter) in $e$ that explicitly uses the enum type $\epsilon$ to $\epsilon$ (if it isn't already). Then:
\begin{enumerate}
    \item If $check(\emptyset,\, e')$ succeeds (i.e., all the type-checking rules can be applied without failure on $e'$), it verifies that the enum type $\epsilon$ can be treated as a subtype of the integer type (meaning that $\epsilon$ can be safely translated as a Rust enum type).
    \item Suppose $\checktype{\emptyset}{e'}{\tau}{\Gamma_1}$ (the type checker infers type $\tau$ for $e'$ and produces environment $\Gamma_1$). If we then modify the declared type of every variable $x$ found in $\Gamma_1$ to $\Gamma_1(x)$ in the original program (producing a new program $e''$), then $e''$ is well-typed. In other words, after inferring the appropriate enum types via $\Gamma_1$, applying those types back to the program yields a consistent, type-correct program.
    \item Only necessary changes are made to the program $e'$ to produce $e''$. In other words, reverting any change of type annotation in $e''$ as in $e'$ will result in a type error.
\end{enumerate}

\begin{proof}
    See Appendix.
\end{proof}

\subsection{Examples}
We first consider a simple code fragment (assuming that $0 \in V_\epsilon$):
\[
\lett{x}{\Z}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

In this code, $y$ is explicitly declared with type $\epsilon$, so we interpret that as the developer intending $y$ to be of the enum type. To avoid any type errors, our system should infer that $x$ also has type $\epsilon$ because $x$ is initialized to $0$ (and we assumed $0 \in V_\epsilon$). Inferring $x:\epsilon$ is valid here since $0$ is one of $\epsilon$'s variant values. In contrast, $z$ is declared as an $\mathbb{Z}$ (integer) and has no connection to $\epsilon$ apart from coincidentally being assigned $0$. Therefore, $z$ should \emph{not} be inferred as type $\epsilon$.

By applying the subtype inference rules, we find that only $x$ gets associated with the enum type $\epsilon$ (while $z$ remains an integer).

If we then change the declaration of the associated variable $x$ to use type $\epsilon$ (as inferred), the resulting code becomes well-typed with the enum type correctly applied:
\[
\lett{x}{\epsilon}{0}{
    \{\ \lett{y}{\epsilon}{x}{\{\ 
        \lett{z}{\Z}{0}{z}
    \ \}}\ \}
}\]

We can also confirm that this approach works when functions are involved. Consider the following example:
\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\Z}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

In this code, the function \texttt{ctoi} expects a parameter of type $\epsilon$ and returns an integer (the value multiplied by 3). The variable \texttt{green} is declared with type $\Z$ and assigned 1, but when we pass \texttt{green} to \texttt{ctoi}, that usage effectively associates \texttt{green} with the enum type $\epsilon$ (since \texttt{ctoi} requires an $\epsilon$ argument). Therefore, \texttt{green} should be inferred to have type $\epsilon$. Applying the formal rules confirms this inference, resulting in the following well-typed code (with \texttt{green} now declared as type $\epsilon$):
\[
\begin{array}{l}
    \lett{ctoi}{\arrowt{\epsilon}{\Z}}{\funct{c}{\epsilon}{(3\times c)}}{}\\
    \quad \lett{green}{\epsilon}{1}{} \\
    \quad \quad \apply{ctoi}{green}
\end{array}
\]

These examples illustrate that the formal rules correctly identify when a C enum type can be translated to a Rust enum type and guide the necessary transformations. The subtype inference approach helps determine when a C enum can be upgraded to a Rust enum in translation, and it carries out the replacement of the integer alias with a Rust enum where it is valid to do so.

\section{Conclusion}
In this report, we presented an approach to enhance C2Rust's enum translation by introducing subtype inference. Our approach determines when a given C enum can be safely translated into a Rust enum and, if feasible, replaces the integer type alias with a proper Rust enum. By leveraging Rust's value safety and expressiveness for enums, the translation process produces output code that is more idiomatic and maintains type correctness.

This approach offers several benefits. First, it improves the accuracy of the translation by inferring and enforcing the intended enum types, which leads to fewer type errors and a smoother migration from C to Rust. Second, by replacing opaque integer aliases with meaningful Rust enums, it enhances the readability and maintainability of the code. Developers can more easily understand the intent of the code when enums are used instead of generic integers. Finally, by eliminating the need for downcasting in the translated code, our approach reduces the reliance on unsafe Rust constructs, making the resulting code safer and more idiomatic.

However, our approach in its current form relies on a strict static type analysis and may fail in certain cases that a human might still consider valid enum usage. For example, consider a common C idiom:

\begin{lstlisting}[language=C]
enum Day {
    Mon, Tue, Wed, Thu, Fri, Sat, Sun
};

enum Day next_day(enum Day day) {
    return (day + 1) % 7;
}
\end{lstlisting}

This code uses an enum to represent days of the week and calculates the next day. For a successful translation to a Rust enum, we would need to deduce that the return value of \texttt{next\_day} is always between 0 and 6 (i.e., a valid \texttt{Day}). However, the type system alone cannot guarantee this property, so our formal rules would not allow translating the return type of \texttt{next\_day} as an enum. Handling such cases would require additional analysis, such as range analysis or value constraint inference. Instead of automatically concluding that an expression involving arithmetic cannot correspond to an enum, the translator could attempt to deduce constraints on the expression's possible values and determine whether it stays within the valid range of an enum's variants. Incorporating such analysis could enable us to capture more cases where a C enum type can be translated to a Rust enum type.

\appendix

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}

\section*{Preliminaries}

We define the several notations and rules for the formal proof:

\begin{itemize}
    \item \textbf{Forcing rules:} The \textbf{Forcing Rules} are the set of rules that force a type to be a subtype of another type, including \textsc{Check-Lambda-Force}, \textsc{Require-Lambda-Force}, \textsc{Check-Let-Force}, and \textsc{Require-Let-Force}.
    \item \textbf{Type kinds:} We say the types $\tau_1$ and $\tau_2$ are of the same kind, denoted as $\tau_1 \sim \tau_2$, by the following rules:
    \[\tau\sim\tau\quad\infer{\tau_1\sim\tau_3}{\tau_1\sim\tau_2\quad\tau_2\sim\tau_3}\quad\infer{\tau_1\sim\tau_2}{\tau_2\sim\tau_1}\quad\infer{\tau_1\sim\tau_2}{\tau_1<:\tau_2}\quad\infer{\arrowt{\tau_1}{\tau_2}\;\sim\;\arrowt{\tau_3}{\tau_4}}{\tau_1\sim\tau_3\quad\tau_2\sim\tau_4}\]
    \item \textbf{Type Environment kinds:} We say the type environments $\Gamma_1$ and $\Gamma_2$ are of the same kind, denoted as $\Gamma_1 \sim \Gamma_2$, if $\text{Domain}(\Gamma_1) = \text{Domain}(\Gamma_2)$ and for all $x \in \text{Domain}(\Gamma_1)$, $\Gamma_1(x) \sim \Gamma_2(x)$.
    \item \textbf{Bounds:} We say the type $\tau$ is the upper bound of a types $\tau_1$ and $\tau_2$ if $\tau_1 <: \tau$ and $\tau_2 <: \tau$. We define the least upper bound of two types $\tau_1$ and $\tau_2$ as $\tau_1 \sqcup \tau_2$, i.e., for all upper bounds $\tau$ of $\tau_1$ and $\tau_2$, $\tau_1 \sqcup \tau_2 <: \tau$. Similarly, we define the greatest lower bound of two types $\tau_1$ and $\tau_2$ as $\tau_1 \sqcap \tau_2$, i.e., for all lower bounds $\tau$ of $\tau_1$ and $\tau_2$, $\tau \sqcap \tau_2 <: \tau$.
    \item \textbf{Expression cases:} For the inductive steps, we name the cases of expressions as follows:
    \begin{itemize}
        \item \textsc{Let}: \lett{x}{\tau}{e}{e}
        \item \textsc{Var}: $x$
        \item \textsc{Const}: $n$
        \item \textsc{BinOp}: \binop{e}{e}
        \item \textsc{Ternary}: \ternary{e}{e}{e}
        \item \textsc{Lambda}: \funct{x}{\tau}{e}
        \item \textsc{Apply}: \apply{e}{e}
    \end{itemize}

    The base cases of the expression are \textsc{Var} and \textsc{Const}. Other cases are inductive.
    \item \textbf{Type cases:} For the type, we name the cases as follows:
    \begin{itemize}
        \item \textsc{Epsilon}: $\epsilon$
        \item \textsc{Integer}: $\Z$
        \item \textsc{Arrow}: $\arrowt{\tau}{\tau}$
    \end{itemize}

    The base cases of the type are \textsc{Epsilon} and \textsc{Integer}. The \textsc{Arrow} type is inductive.
    \item \textbf{Environments:} To avoid confusion, we call $\Gamma$ the \textbf{type environment} if it is used in the first argument of the $check$ or $require$ functions, and we call it the \textbf{associated type environment} if it is returned by the $check$ or $require$ functions.
    \item \textbf{Applying an associated type environment:} We call the process of applying an associated type environment $\Gamma$ to an expression $e$ as \textbf{applying the environment} to $e$, and denote it as $\Gamma[e]$. This is the process on the proposition 2, where we apply the associated type environment $\Gamma_1$ to the expression $e'$ to produce a new expression $e''$(i.e., $e'' = \Gamma_1[e']$). Following is the formal definition of applying an associated type environment to an expression:
    \begin{itemize}
        \item \textsc{Var}: $\Gamma[x]$ is $x$.
        \item \textsc{Const}: $\Gamma[n]$ is $n$.
        \item \textsc{Let}: If $x\in \text{Domain}(\Gamma)$ and $\Gamma(x)<:\tau$, $\Gamma[\lett{x}{\tau}{e_1}{e_2}]$ is $\lett{x}{\Gamma(x)}{\Gamma[e_1]}{\Gamma[e_2]}$.

        Otherwise, $\Gamma[\lett{x}{\tau}{e_1}{e_2}]$ is $\lett{x}{\tau}{\Gamma[e_1]}{\Gamma[e_2]}$.
        \item \textsc{BinOp}: $\Gamma[\binop{e_1}{e_2}]$ is $\binop{\Gamma[e_1]}{\Gamma[e_2]}\quad$.
        \item \textsc{Ternary}: $\Gamma[\ternary{e_1}{e_2}{e_3}]$ is $\ternary{\Gamma[e_1]}{\Gamma[e_2]}{\Gamma[e_3]}$.
        \item \textsc{Lambda}: If $x\in \text{Domain}(\Gamma)$ and $\Gamma(x)<:\tau$, $\Gamma[\funct{x}{\tau}{e}]$ is $\funct{x}{\Gamma(x)}{\Gamma[e]}$.

        Otherwise, $\Gamma[\funct{x}{\tau}{e}]$ is $\funct{x}{\tau}{\Gamma[e]}$.
        \item \textsc{Apply}: $\Gamma[\apply{e_1}{e_2}]$ is $\apply{\Gamma[e_1]}{\Gamma[e_2]}$.
    \end{itemize}
    \item \textbf{Declaration on expression}: If an expression $e$ contains a subexpression \lett{x}{\tau}{e_1}{e_2} or $\funct{x}{\tau}{e}$, we say that $e$ has a \textbf{declaration} of $x$.
\end{itemize}


\section*{Properties}

\begin{lemma}
    \label{lem:bound}
    If $\tau_1\sim\tau_2$, then $\tau_1\sqcup\tau_2$ and $\tau_1\sqcap\tau_2$ exists.
\end{lemma}

\begin{proof}
    We use induction on the type $\tau_1$.

    \textbf{Base Cases:}
    \begin{itemize}
        \item \textsc{Epsilon}: $\epsilon\sqcup\tau_2=\tau_2$ and $\epsilon\sqcap\tau_2=\epsilon$.
        \item \textsc{Integer}: $\Z\sqcup\tau_2=\tau_2$ and $\Z\sqcap\tau_2=\Z$.
    \end{itemize}

    \textbf{Inductive Cases:}
    \begin{itemize}
        \item \textsc{Arrow} $\tau_1=\arrowt{\tau_a}{\tau_b}$ and $\tau_2=\arrowt{\tau_c}{\tau_d}$: By the inductive hypothesis, we have $\tau_a\sim\tau_c$ and $\tau_b\sim\tau_d$. Then, we have an upper bound $\tau_u=\arrowt{(\tau_a\sqcap\tau_c)}{(\tau_b\sqcup\tau_d)}$ and a lower bound $\tau_l=\arrowt{(\tau_a\sqcup\tau_c)}{(\tau_b\sqcap\tau_d)}$.
        
        Suppose $\tau_u'=\arrowt{\tau_{u_a}}{\tau_{u_b}}$ is an upper bound of $\tau_1$ and $\tau_2$, then we have $\tau_{u_a} <: \tau_a$, $\tau_{u_a} <: \tau_c$, $\tau_b <: \tau_{u_b}$ and $\tau_d <: \tau_{u_b}$. Therefore, we have $\tau_{u_a} <: \tau_a\sqcap\tau_c$ and $\tau_b\sqcup\tau_d <: \tau_{u_b}$. Thus, we have $\tau_u <: \tau_u'$, which means $\tau_u$ is a least upper bound of $\tau_1$ and $\tau_2$. Similarly, we can show that $\tau_l$ is a greatest lower bound of $\tau_1$ and $\tau_2$.
    \end{itemize}

    Therefore, we conclude that $\tau_1\sqcup\tau_2$ and $\tau_1\sqcap\tau_2$ always exist.
\end{proof}

\begin{lemma}
    \label{lem:same-kind}
    For all $\Gamma_1$, $\Gamma_2$ and $e$ where $\Gamma_1\sim\Gamma_2$, if $\checktype{\Gamma_1}{e}{\tau_1}{\Gamma_1'}$ and $\checktype{\Gamma_2}{e}{\tau_2}{\Gamma_2'}$, then $\tau_1\sim\tau_2$. Also, if $require(\Gamma,\,e,\,\tau_1)$ and $require(\Gamma,\,e,\,\tau_2)$ both succeed, then $\tau_1\sim\tau_2$.
\end{lemma}

\begin{proof}
    Easy.
\end{proof}

\begin{lemma}
    \label{lem:env-kind}
    If $\Gamma_1\sim\Gamma_2$ and $\tau_1\sim\tau_2$, then $\Gamma_1[x:\tau_1]\sim\Gamma_2[x:\tau_2]$.
\end{lemma}

\begin{proof}
    Easy.
\end{proof}

\begin{theorem}
    \label{thm:assoc-iden}
    For all $\Gamma_1$, $\Gamma_2$ and $e$ where $\Gamma_1\sim\Gamma_2$, suppose there exists a type $\tau$ such that $require(\Gamma_1, e, \tau)$ and $require(\Gamma_2, e, \tau)$ both succeed with $\requiretype{\Gamma_1}{e}{\tau}{\Gamma_1'}$ and $\requiretype{\Gamma_2}{e}{\tau}{\Gamma_2'}$. Then, $\Gamma_1'=\Gamma_2'$. Also, if $check(\Gamma_1, e)$ and $check(\Gamma_2, e)$ both succeed with $\checktype{\Gamma_1}{e}{\tau_1}{\Gamma_1'}$ and $\checktype{\Gamma_2}{e}{\tau_2}{\Gamma_2'}$, then $\Gamma_1'=\Gamma_2'$.
\end{theorem}

\begin{proof}
    We use induction on the expression $e$.

    \textbf{Base Cases:}
    \begin{itemize}
        \item \textsc{Const} $n$: According to the rule \textsc{Require-ConstEnum}, \textsc{Check-ConstEnum} and \textsc{Check-ConstNonEnum}, the associated type environment is always $\emptyset$.
        \item \textsc{Var} $x$: According to the rule \textsc{Require-Var-Env}, the associated type environment by $require$ is always $[x:\tau]$. The rule \textsc{Check-Var} always gives the empty environment $\emptyset$.
    \end{itemize}

    \textbf{Inductive Cases:}
    \begin{itemize}
        \item \textsc{Let} \lett{x}{\tau_1}{e_1}{e_2}: For $require$, we have 3 rules: \textsc{Require-Let-Req}, \textsc{Require-Let-NoReq}, and \textsc{Require-Let-Force}. All of them gets two associated type environments for $e_1$ and $e_2$, and gives a union of the two as the result. Therefore, it is sufficient to show that the two associated type environments are the same for $e_1$ and $e_2$.
        \begin{itemize}
            \item For $e_2$, all the rules use $require$ with the same kind of type environment, the same expression, and the same type. Therefore, by the induction hypothesis, we will have the same associated type environment.
            \item For $e_1$, the given type environment is the same kind for all the rules. If $\tau_1$ is required, then $e$ will check the rule \textsc{Require-Let-Req}. If $\tau_1$ is not required, then $e$ will check the rule \textsc{Require-Let-NoReq} only if $x$ is not in the domain of the associated type environment of $e_2$. Otherwise, it will check the rule \textsc{Require-Let-Force}. Therefore, the rule which will be used for $require$ depends on the expression $e$, not the type environment $\Gamma_1$ or $\Gamma_2$. Using this fact, deriving $\Gamma_1'=\Gamma_2'$ is straightforward with the induction hypothesis.
        \end{itemize}

        In this case, $check$ is similar to $require$.
        \item \textsc{BinOp} \binop{e_1}{e_2}: $require$ will not succeed if the type $\tau$ is required. Otherwise, $\checktype{\Gamma}{e}{\tau}{\Gamma'}\Rightarrow\requiretype{\Gamma}{e}{\tau}{\Gamma'}$ by the rule \textsc{Require-Expr-NoReq}. By the induction hypothesis and the rule \textsc{Check-BinOp}, we have $\Gamma_1'=\Gamma_2'$.
        \item \textsc{Ternary}: By the induction hypothesis and the rules \textsc{Require-Ternary} and \textsc{Check-Ternary}, we have $\Gamma_1'=\Gamma_2'$.
        \item \textsc{Lambda}: It's basically same as \textsc{Let} case without $e_1$, thus easier to prove.
        \item \textsc{Apply} \apply{e_1}{e_2}: For $require$:
        \begin{itemize}
            \item By inductive hypothesis, suppose $\checktype{\Gamma_1}{e_1}{\tau_1}{\Gamma_a}$ and $\checktype{\Gamma_2}{e_1}{\tau_2}{\Gamma_b}$.
            \item By Lemma~\ref{lem:same-kind}, we have $\tau_1\sim\tau_2$.
            \item By Lemma~\ref{lem:bound}, let $\tau_u=\tau_1\sqcup\tau_2$. 
            \item In order to pass the rule \textsc{Require-Apply}, $\tau_1=\arrowt{\tau_{1a}}{\tau_{1b}}$, $\tau_2=\arrowt{\tau_{2a}}{\tau_{2b}}$, and $\forcerequire{\tau_{1b}}{\tau}$ and $\forcerequire{\tau_{2b}}{\tau}$.
            \item Suppose $\tau_u=\arrowt{\tau_{ua}}{\tau_{ub}}$. Then, $\tau_{ub}=\tau_{1b}\sqcup\tau_{2b}$. Therefore, we conclude that $\forcerequire{\tau_{ub}}{\tau}$.
            \item By the rule \textsc{Check-Subsumption}, we have $\checktype{\Gamma_1}{e_1}{\tau_u}{\Gamma_c}$ and $\checktype{\Gamma_2}{e_1}{\tau_u}{\Gamma_d}$.
            \item Using $\tau_u$ in the rule \textsc{Require-Apply} and by the induction hypothesis, we have $\Gamma_1'=\Gamma_2'$.
        \end{itemize}
        $check$ is easier than $require$ because it does not have type forcing.
    \end{itemize}
\end{proof}

\begin{theorem}
    \label{thm:check-well-typed}
    For some $\tau$, if $check(\Gamma, e)$ or $require(\Gamma, e, \tau)$ succeeds without any \textbf{Forcing Rules} applied, then $e$ is well-typed under the type environment $\Gamma$.
\end{theorem}

\begin{proof}
    Easy.
\end{proof}

\begin{theorem}
    \label{thm:check-ill-typed}
    For some $\tau$, if $check(\Gamma, e)$ or $require(\Gamma, e, \tau)$ succeeds with some \textbf{Forcing Rules} applied, then $e$ is not well-typed under the type environment $\Gamma$.
\end{theorem}

\begin{proof}
    Easy.
\end{proof}

\begin{lemma}
    \label{lem:contains-declaration-or-tenv}
    Suppose \checktype{\Gamma}{e}{\tau}{\Gamma'} or \requiretype{\Gamma}{e}{\tau}{\Gamma'}. For $x \in\domain{\Gamma'}$, either $e$ contains a declaration of $x$ or $x\in\domain{\Gamma}$.
\end{lemma}

\begin{proof}
    Easy.
\end{proof}

\begin{lemma}
    \label{lem:apply-iden}
    If there's no such $x\in\domain{\Gamma_1}$ such that $e$ contains a declaration of $x$, then $\Gamma_2[e]=(\Gamma_1\cup\Gamma_2)[e]$ for all $\Gamma_1$, $\Gamma_2$ and $e$.
\end{lemma}

\begin{theorem}
    \label{thm:check-apply}
    If $\checktype{\Gamma}{e}{\tau}{\Gamma'}$, then $check(\Gamma,\,\Gamma'[e])$ produces the same result(both type and associated type environment) without any \textbf{Forcing Rules} applied. Also, if $\requiretype{\Gamma}{e}{\tau}{\Gamma'}$, then $require(\Gamma,\,\Gamma'[e], \tau)$ produces the same result without any \textbf{Forcing Rules} applied.
\end{theorem}

\begin{proof}
    We use induction on the expression $e$.

    \textbf{Base Cases:} Easy.

    \textbf{Inductive Cases:}
    \begin{itemize}
        \item \textsc{BinOp} \binop{e_1}{e_2}: No $require$ rule for this case, so we only consider $check$.
        \begin{itemize}
            \item By the rule \textsc{Check-BinOp}, we have $\checktype{\Gamma}{e_1}{\Z}{\Gamma_1}$ and $\checktype{\Gamma}{e_2}{\Z}{\Gamma_2}$.
            \item If $e_1$ has a declaration of $x$, then we get $x\notin\domain{\Gamma}$ by Lemma~\ref{lem:contains-declaration-or-tenv}. Also, by the no-naming-collision assumption, $e_2$ does not have a declaration of $x$. 
            \item By Lemma~\ref{lem:contains-declaration-or-tenv}, we have $x\notin\domain{\Gamma_2}$. Therefore, by Lemma~\ref{lem:apply-iden}, we have $\Gamma_1[e_1]=(\Gamma_1\cup\Gamma_2)[e_1]$. 
            \item In the same way, we have $\Gamma_2[e_2]=(\Gamma_1\cup\Gamma_2)[e_2]$.
            \item By inductive hypothesis, we have $\checktype{\Gamma}{\Gamma_1[e_1]}{\Z}{\Gamma_1}$ and $\checktype{\Gamma}{\Gamma_2[e_2]}{\Z}{\Gamma_2}$.
            \item Using the fact that $\Gamma_1[e_1]=(\Gamma_1\cup\Gamma_2)[e_1]$ and $\Gamma_2[e_2]=(\Gamma_1\cup\Gamma_2)[e_2]$, we have $\checktype{\Gamma}{\Gamma'[e]}{\Z}{\Gamma'}$.
        \end{itemize}
        \item \textsc{Ternary}: Both $require$ and $check$ cases are similar to \textsc{BinOp} case.
        \item \textsc{Apply}: Similar to \textsc{Ternary} case.
        \item \textsc{Let} \lett{x}{\tau_1}{e_1}{e_2}: 
        First of all, in the same way as in the \textsc{BinOp} case, we can show that $\Gamma_1[e_1]=(\Gamma_1\cup\Gamma_2)[e_1]$ and $\Gamma_2[e_2]=(\Gamma_1\cup\Gamma_2)[e_2]$. 
        
        For $require$, we have 3 rules: \textsc{Require-Let-Req}, \textsc{Require-Let-NoReq}, and \textsc{Require-Let-Force}. Our objective is to show that $require(\Gamma,\,\Gamma'[e],\,\tau)$ passes either \textsc{Require-Let-Req} or \textsc{Require-Let-NoReq}.
        
        We consider the following cases of which rule is used for $require(\Gamma,\,e,\,\tau)$:
        \begin{itemize}
            \item \textsc{Require-Let-Req}: If $e$ passed this rule, then type annotation of $x$(which is $\tau_1$) is unchanged in $\Gamma'[e]$. Therefore, the statement holds by the inductive hypothesis.
            \item \textsc{Require-Let-NoReq}: If $e$ passed this rule, then type annotation of $x$(which is $\tau_1$) is unchanged in $\Gamma'[e]$. Therefore, the statement holds by the inductive hypothesis.
            \item \textsc{Require-Let-Force}: Suppose $e$ passed this rule by forcing the type $\tau_1$ to be $\tau'$. Then, for the associated type environment $\Gamma_2$ produced by $require(\Gamma[x:\tau'],\,e_2,\,\tau)$, we have $\Gamma_2(x)=\tau'$. The type annotation of $x$ in $\Gamma'[e]$ is $\tau'$, so $require(\Gamma,\,\Gamma'[e],\,\tau)$ now passes the rule \textsc{Require-Let-Req} since $\required{\tau'}$, \requiretype{\Gamma}{\Gamma_1[e_1]}{\tau'}{\Gamma_1} and \requiretype{\Gamma[x:\tau']}{\Gamma_2[e_2]}{\tau}{\Gamma_2}(by inductive hypothesis).
        \end{itemize}

        Therefore, we conclude that $require(\Gamma,\,\Gamma'[e],\,\tau)$ passes either \textsc{Require-Let-Req} or \textsc{Require-Let-NoReq}, and $\requiretype{\Gamma}{\Gamma'[e]}{\tau}{\Gamma'}$.

        For $check$, we can show that $check(\Gamma,\,\Gamma'[e])$ doesn't pass any \textbf{Forcing Rules}, and $\checktype{\Gamma}{\Gamma'[e]}{\tau}{\Gamma'}$ in the same way as above.
        \item \textsc{Lambda}: Easier than \textsc{Let} case.
    \end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:required}
    The associated type environment $\Gamma$ produced by $check$ or $require$ can only have the required types. i.e., for all $x\in\domain{\Gamma}$, $\required{\Gamma(x)}$.
\end{lemma}

\begin{proof}
    Easy.
\end{proof}

\begin{theorem}
    \label{thm:check-apply-force}
    If $\checktype{\Gamma}{e}{\tau}{\Gamma'}$, and for any $\Gamma''\subset\Gamma'$ where $\Gamma''[e]\neq\Gamma'[e]$, $check(\Gamma,\,\Gamma''[e])$ produces the same result, but still uses \textbf{Forcing Rules}. Also, if $\requiretype{\Gamma}{e}{\tau}{\Gamma'}$, and for any $\Gamma''\subset\Gamma'$ where $\Gamma''[e]\neq\Gamma'[e]$, $require(\Gamma,\,\Gamma''[e], \tau)$ produces the same result, but still uses \textbf{Forcing Rules}.
\end{theorem}

\begin{proof}
    Similar induction as in Theorem~\ref{thm:check-apply}.

    \textbf{Base Cases:} Can't happen since $e=\Gamma'[e]=\Gamma''[e]$. Therefore, we only consider the inductive cases.

    \textbf{Inductive Cases:}
    \begin{itemize}
        \item \textsc{BinOp} \binop{e_1}{e_2}: By the assumption, we have $\Gamma''[e_1]\neq\Gamma'[e_1]$ or $\Gamma''[e_2]\neq\Gamma'[e_2]$. We use inductive hypothesis on the subexpression where the difference occurs. Therefore, we conclude that $check(\Gamma,\,\Gamma''[e])$ or $require(\Gamma,\,\Gamma''[e], \tau)$ uses \textbf{Forcing Rules}. Also, by using inductive hypothesis and Theorem~\ref{thm:check-apply}, we have $\checktype{\Gamma}{\Gamma''[e]}{\tau}{\Gamma'}$ or $\requiretype{\Gamma}{\Gamma''[e]}{\tau}{\Gamma'}$, therefore the same result is produced.
        \item \textsc{Ternary}: Similar to \textsc{BinOp} case.
        \item \textsc{Apply}: Similar to \textsc{Ternary} case.
        \item \textsc{Let} \lett{x}{\tau_1}{e_1}{e_2}: For $require$,
        \begin{itemize}
            \item \textbf{Case 1:} $\Gamma'[e]$ and $\Gamma''[e]$ has different type annotation for $x$. i.e., $x\in\domain{\Gamma'}\setminus\domain{\Gamma''}$, and $\Gamma'(x) <: \tau_1$.

            Since $\Gamma'[e]$ changed the type annotation on $x$. According to the \textsc{Let} case in the proof of Theorem~\ref{thm:check-apply}, $require(\Gamma,\,e,\,\tau)$ passes the rule \textsc{Require-Let-Force}. Suppose the type of $x$ has been forced to $\tau'$. This indicates \requiretype{\Gamma[x:\tau']}{e_2}{\tau}{\Gamma_2} for some $\Gamma_2$ and $\Gamma_2(x)=\tau'$.
            Assume $require(\Gamma,\,\Gamma''[e],\,\tau)$ passes the rule:
            \begin{itemize}
                \item \textsc{Require-Let-Req}: 
                \begin{itemize}
                    \item By Theorem~\ref{thm:assoc-iden}, we have $require(\Gamma[x:\tau_1],\,e_2,\,\tau)=\Gamma_2$ since $\Gamma[x:\tau']\sim\Gamma[x:\tau_1]$.
                    \item By the inductive hypothesis and Theorem~\ref{thm:check-apply}, we have $\requiretype{\Gamma[x:\tau_1]}{\Gamma_2[e_2]}{\tau}{\Gamma_2}$.
                    \item In the same way as above, we also have $\requiretype{\Gamma[x:\tau_1]}{\Gamma''[e_2]}{\tau}{\Gamma_2}$.
                    \item Therefore, the rule \textsc{Require-Let-Req} fails, which is a contradiction.
                \end{itemize}
                \item \textsc{Require-Let-NoReq}: In the same way as above, we get a contradiction on $x\notin\domain{\Gamma_2}$.
                \item \textsc{Require-Let-Force}: This implies that $require(\Gamma,\,\Gamma''[e],\,\tau)$ passes the \textbf{Forcing Rules}. It can be shown that $require(\Gamma,\,\Gamma''[e],\,\tau)$ produces the same result as $require(\Gamma,\,\Gamma'[e],\,\tau)$ by the inductive hypothesis, and the Theorem~\ref{thm:check-apply}.
            \end{itemize}
            \item \textbf{Case 2:} $\Gamma'[e]$ and $\Gamma''[e]$ has the same type annotation for $x$: similar to the \textsc{BinOp} case.
        \end{itemize}
        \item \textsc{Lambda}: Similar to \textsc{Let} case.
    \end{itemize}
\end{proof}

\section*{Proof of Propositions}

\begin{proof}

Proving each propositions are straightforward using the above theorems.
\begin{enumerate}
    \item By the proposition 2.
    \item Case where $\Gamma=\emptyset$ in the Theorem~\ref{thm:check-apply} and use Theorem~\ref{thm:check-well-typed}.
    \item Case where $\Gamma=\emptyset$ in the Theorem~\ref{thm:check-apply-force} and use Theorem~\ref{thm:check-ill-typed}.
\end{enumerate}
\end{proof}

\end{document}
