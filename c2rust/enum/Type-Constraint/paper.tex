\documentclass{article}[10pt]
\usepackage[left=1in,right=1in,top=1in,bottom=1in,a4paper]{geometry}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}

\newcommand{\C}[1]{{\small\tt #1}}

\begin{document}

\title{}
\author{}
\date{}
%\maketitle

\paragraph{Basic MIR}

\[
  \begin{array}{@{}rcl@{}}
    n &\in& \mathbb{Z} \\
    x,y &\in& \mathit{Id} \\
    f &:=& \overline{B:b};\overline{x:\tau} \\
    b &:=& \overline{s}; t \\
    s &:=& x=n\ |\ x=y\ |\ x={\it unop}\ y\ |\ x=y_1\ {\it binop}\ y_2 \\
    t &:=& {\sf goto}\ B\ |\ {\sf switch}\ x\ \overline{n:B}\ |\ {\sf return} \\
    \epsilon &\in& \mathit{Enum} \\
    \tau &:=& {\sf int}\ |\ \epsilon \\
  \end{array}
\]

In MIR, a function $f$ is represented with the type
\C{Body}\footnote{\url{https://doc.rust-lang.org/beta/nightly-rustc/rustc\_middle/mir/struct.Body.html}},
which denotes a control flow graph (CFG) consisting of multiple basic blocks.
%
Each basic block $b$ is represented with the type
\C{BasicBlockData}\footnote{\url{https://doc.rust-lang.org/beta/nightly-rustc/rustc\_middle/mir/struct.BasicBlockData.html}}
and consists of multiple statements followed by a single terminator.
%
In a basic block, statements do not have any control flow effect, and only
terminators affect the control flow.
%
A basic block is associated with a unique identifier $B$, represented with the
type
\C{BasicBlock}\footnote{\url{https://doc.rust-lang.org/beta/nightly-rustc/rustc\_middle/mir/struct.BasicBlock.html}}.
%
A statement $s$ has the type
\C{Statement}\footnote{\url{https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/mir/struct.Statement.html}}.
%
While various kinds of statements exist in MIR, we only need to consider
assignments.
%
The left-hand side of an assignment is a variable $x$, and the right-hand side
is either an integer $n$, a variable, a unary operation, or a binary operation.
%
A terminator $t$ has the type
\C{Terminator}\footnote{\url{https://doc.rust-lang.org/beta/nightly-rustc/rustc\_middle/mir/struct.Terminator.html}}
and is either a jump to another basic block, a switch, or a return.
%
When returning, the return value is always the value stored in the variable
named \C{\_0}.
%
If a function has $n$ parameters, their values are stored in the variables
\C{\_1}, \C{\_2}, \ldots, \C{\_n}.
%
Note that a function declares the type of each variable as well.
%
A type $\tau$ is either \C{int} or a C \C{enum} type $\epsilon$.

\paragraph{Adding pointers}

\[
  \begin{array}{@{}rcl@{}}
    s &:=& \cdots\ |\ x=\&y\ |\ x=*y\ |\ *x=y \\
    \tau &:=& \cdots\ |\ *\tau \\
  \end{array}
\]

\paragraph{Adding structs and arrays}

\[
  \begin{array}{@{}rcl@{}}
    F &\in& \mathit{Field} \\
    S &\in& \mathit{Struct} \\
    s &:=& \cdots\ |\ x.F=y\ |\ x=y.F\ |\ x[x']=y\ |\ x=y[y'] \\
    \tau &:=& \cdots\ |\ S\ |\ \tau[] \\
    p &:=& \overline{S \{ \overline{F:\tau} \}}; \overline{f} \\
  \end{array}
\]

\paragraph{Adding function calls}

\[
  \begin{array}{@{}rcl@{}}
    g &\in& \mathit{Function} \\
    p &:=& \overline{S \{ \overline{F:\tau} \}}; \overline{g:f} \\
    t &:=& \cdots\ |\ x=g(\overline{y}); B \\
  \end{array}
\]

\paragraph{Adding function pointers}

\[
  \begin{array}{@{}rcl@{}}
    s &:=& \cdots\ |\ x=g \\
    t &:=& \cdots\ |\ x=y(\overline{y'}); B \\
    \tau &:=& \cdots\ |\ \overline{\tau}\rightarrow\tau' \\
  \end{array}
\]

\end{document}
